<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Mechanics of Defect Evolution Library: /home/giacomo/Dropbox/Model/model/BVP/Triangle.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://www.mathjax.org/mathjax/MathJax.js"></script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="UCLA_LOGO.jpeg"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mechanics of Defect Evolution Library
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/giacomo/Dropbox/Model/model/BVP/Triangle.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* This file is part of finite element solution of BVP attached with mmdl &quot;the Mechanics of Material Defects Library&quot;.</span>
<a name="l00002"></a>00002 <span class="comment"> *</span>
<a name="l00003"></a>00003 <span class="comment"> * Copyright (C) 2011 by Mamdouh Mohamed &lt;mamdouh.s.mohamed@gmail.com&gt;, </span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (C) 2011 by Giacomo Po &lt;giacomopo@gmail.com&gt;.</span>
<a name="l00005"></a>00005 <span class="comment"> * </span>
<a name="l00006"></a>00006 <span class="comment"> * mmdl is distributed without any warranty under the </span>
<a name="l00007"></a>00007 <span class="comment"> * GNU General Public License (GPL) v2 &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00008"></a>00008 <span class="comment"> */</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="preprocessor">#ifndef bvpfe_triangle_H_</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span><span class="preprocessor">#define bvpfe_triangle_H_</span>
<a name="l00012"></a>00012 <span class="preprocessor"></span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &quot;mmdl/Utilities/StaticID.h&quot;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &quot;mmdl/BVP/Element.h&quot;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00017"></a>00017 <span class="comment">//#include &quot;mmdl/BVP/Tetrahedron.h&quot;</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="comment">//#include &quot;mmdl/Quadrature/Quadrature.h&quot;</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="keyword">namespace </span>bvpfe {
<a name="l00022"></a>00022   
<a name="l00023"></a>00023         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> S&gt;
<a name="l00024"></a><a class="code" href="structbvpfe_1_1_pointer_wrapper.html">00024</a>         <span class="keyword">struct </span><a class="code" href="structbvpfe_1_1_pointer_wrapper.html">PointerWrapper</a> {
<a name="l00025"></a>00025                 <span class="keyword">const</span> S* <span class="keyword">const</span> pt;
<a name="l00026"></a>00026                 <a class="code" href="structbvpfe_1_1_pointer_wrapper.html">PointerWrapper</a>(<span class="keyword">const</span> S* <span class="keyword">const</span> ptin):pt(ptin){}
<a name="l00027"></a>00027         };
<a name="l00028"></a>00028   
<a name="l00029"></a>00029 
<a name="l00030"></a><a class="code" href="classbvpfe_1_1_triangle.html">00030</a>         <span class="keyword">class </span><a class="code" href="classbvpfe_1_1_triangle.html">Triangle</a>    : <span class="keyword">public</span> bvpfe::<a class="code" href="classbvpfe_1_1_element.html">Element</a>&lt;2&gt;, 
<a name="l00031"></a>00031                             <span class="keyword">public</span> mmdl::StaticID&lt;Triangle&gt;  
<a name="l00032"></a>00032 
<a name="l00033"></a>00033         {        
<a name="l00034"></a>00034 
<a name="l00035"></a>00035                 <span class="keyword">public</span> :
<a name="l00036"></a>00036 
<a name="l00037"></a>00037                   <span class="keyword">enum</span>{dim=3};
<a name="l00038"></a>00038                   
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;mmdl/BVP/commonTypeDefs.h&gt;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041                 <span class="comment">//--- the value of the 3 shape functions at three Gauss points (1/3, 1/3)</span>
<a name="l00042"></a>00042                 <span class="keyword">static</span> <span class="keywordtype">double</span> N[3][3];          <span class="comment">// definition of that as std::vector&lt;double&gt; made a problem</span>
<a name="l00043"></a>00043                 <span class="keywordtype">size_t</span> neighTetIndx;        <span class="comment">// index to the neighbor tetrahedron for this surface triangle</span>
<a name="l00044"></a>00044                 
<a name="l00045"></a>00045                 std::vector&lt;Triangle*&gt; neighbor;   <span class="comment">// pointers to the 3 neighbor triangles to this triangle</span>
<a name="l00046"></a>00046                 
<a name="l00047"></a>00047                 std::vector&lt;std::pair&lt;unsigned int,unsigned int&gt; &gt; cuttingSegments;   <span class="comment">// pair nodes for dislocation segments that cut the triangle</span>
<a name="l00048"></a>00048                 
<a name="l00049"></a>00049                 std::map&lt;unsigned int, std::vector&lt;VectorDim&gt; &gt; localQuadPnts;     <span class="comment">// stores the customly generated Quadrature points around each glide plane that intersects the triangle</span>
<a name="l00050"></a>00050                                                                                    <span class="comment">// , where the key is the glide plane sID</span>
<a name="l00051"></a>00051                                                                                    
<a name="l00052"></a>00052                 std::map&lt;unsigned int, double &gt; localQuadPnts_w;                    <span class="comment">// the associated weight with each quadrature points set. Weights are equal for all points, and they have to sum to 0.5</span>
<a name="l00053"></a>00053                 
<a name="l00054"></a>00054                 Eigen::Matrix&lt;unsigned int,2,1&gt; projPlaneIndx;                        <span class="comment">// the index for the projection plane for this triangle</span>
<a name="l00055"></a>00055                 
<a name="l00056"></a>00056                 VectorDim outNormal;       <span class="comment">// The outward normal to the surface triangle</span>
<a name="l00057"></a>00057                 
<a name="l00058"></a>00058                 <span class="keyword">static</span> <span class="keywordtype">double</span> edgeTol;
<a name="l00059"></a>00059 
<a name="l00060"></a>00060                 <a class="code" href="classbvpfe_1_1_triangle.html">Triangle</a>()
<a name="l00061"></a>00061                 {
<a name="l00062"></a>00062                         <span class="comment">//--------- set the basis functions (linear) derivative values  // do it only once</span>
<a name="l00063"></a>00063                         <span class="keywordflow">if</span>  (this-&gt;sID == 0)   setBasis();
<a name="l00064"></a>00064                         neighbor.resize(3);
<a name="l00065"></a>00065                         
<a name="l00066"></a>00066                         <span class="comment">//---------- set the projection plane for this triangle -----</span>
<a name="l00067"></a>00067                         <span class="comment">//projPlaneIndx= find2DProjectionPlane();</span>
<a name="l00068"></a>00068                 }               
<a name="l00069"></a>00069 
<a name="l00070"></a>00070                 <span class="comment">//===================================================================</span>
<a name="l00071"></a>00071                 <span class="comment">// function to calculate the basis functions at 3 Gauss point (1/6, 2/3) . Linear basisare used </span>
<a name="l00072"></a>00072                 <span class="comment">//===================================================================</span>
<a name="l00073"></a>00073 
<a name="l00074"></a>00074                 <span class="keywordtype">void</span> setBasis ()
<a name="l00075"></a>00075                 {
<a name="l00076"></a>00076                         <span class="keywordtype">double</span> twothird , onesixth;
<a name="l00077"></a>00077                         
<a name="l00078"></a>00078                         twothird = 2.0e+00/ 3.0e+00;
<a name="l00079"></a>00079                         onesixth = 1.0e+00/ 6.0e+00;
<a name="l00080"></a>00080 
<a name="l00081"></a>00081                         N[0][0] = 1.0e+00-twothird-onesixth ;  N[0][1] = twothird;   N[0][2] = onesixth;
<a name="l00082"></a>00082                         N[1][0] = 1.0e+00-twothird-onesixth ;  N[1][1] = onesixth;   N[1][2] = twothird;
<a name="l00083"></a>00083                         N[2][0] = 1.0e+00-onesixth-onesixth ;  N[2][1] = onesixth;   N[2][2] = onesixth;
<a name="l00084"></a>00084 
<a name="l00085"></a>00085                         <span class="comment">//std::cout&lt;&lt; N[0] &lt;&lt;&quot; &quot; &lt;&lt; N[1]&lt;&lt; &quot; &quot; &lt;&lt; N [2] &lt;&lt; std::endl;</span>
<a name="l00086"></a>00086                         
<a name="l00087"></a>00087                 }
<a name="l00088"></a>00088                                 
<a name="l00089"></a>00089                 <span class="comment">//============================================================================</span>
<a name="l00090"></a>00090                 <span class="comment">// function to return area of the actual triangle (used in Gauss integration)</span>
<a name="l00091"></a>00091                 <span class="comment">//=============================================================================</span>
<a name="l00092"></a>00092 
<a name="l00093"></a>00093                 <span class="keywordtype">double</span> area()<span class="keyword"> const</span>
<a name="l00094"></a>00094 <span class="keyword">                </span>{
<a name="l00095"></a>00095                         <span class="keywordtype">double</span> ar;
<a name="l00096"></a>00096                         <span class="keywordtype">double</span> a[3] , b[3];
<a name="l00097"></a>00097 
<a name="l00098"></a>00098                         a[0] = this-&gt;eleNodes[1]-&gt;P(0) - this-&gt;eleNodes[0]-&gt;P(0);
<a name="l00099"></a>00099                         a[1] = this-&gt;eleNodes[1]-&gt;P(1) - this-&gt;eleNodes[0]-&gt;P(1);
<a name="l00100"></a>00100                         a[2] = this-&gt;eleNodes[1]-&gt;P(2) - this-&gt;eleNodes[0]-&gt;P(2);
<a name="l00101"></a>00101 
<a name="l00102"></a>00102                         b[0] = this-&gt;eleNodes[2]-&gt;P(0) - this-&gt;eleNodes[0]-&gt;P(0);
<a name="l00103"></a>00103                         b[1] = this-&gt;eleNodes[2]-&gt;P(1) - this-&gt;eleNodes[0]-&gt;P(1);
<a name="l00104"></a>00104                         b[2] = this-&gt;eleNodes[2]-&gt;P(2) - this-&gt;eleNodes[0]-&gt;P(2);
<a name="l00105"></a>00105                 
<a name="l00106"></a>00106                         ar = pow((a[1]*b[2])-(a[2]*b[1]),2) + pow((a[2]*b[0])-(a[0]*b[2]),2) +  pow((a[0]*b[1])-(a[1]*b[0]),2);
<a name="l00107"></a>00107 
<a name="l00108"></a>00108                         ar = sqrt(ar)/ 2.0e+00;
<a name="l00109"></a>00109 
<a name="l00110"></a>00110                         <span class="comment">//std::cout&lt;&lt; &quot;area &quot; &lt;&lt; ar &lt;&lt; std::endl;</span>
<a name="l00111"></a>00111                         <span class="keywordflow">return</span> ar;
<a name="l00112"></a>00112                 }
<a name="l00113"></a>00113                 
<a name="l00114"></a>00114                 <span class="comment">//============================================================================</span>
<a name="l00115"></a>00115                 <span class="comment">// function to return the current (deformed) area of the triangle element (used in indentation force calsulation)</span>
<a name="l00116"></a>00116                 <span class="comment">//=============================================================================</span>
<a name="l00117"></a>00117 
<a name="l00118"></a>00118                 <span class="keywordtype">double</span> deformed_area()<span class="keyword"> const</span>
<a name="l00119"></a>00119 <span class="keyword">                </span>{
<a name="l00120"></a>00120                         <span class="keywordtype">double</span> ar;
<a name="l00121"></a>00121                         <span class="keywordtype">double</span> a[3] , b[3];
<a name="l00122"></a>00122 
<a name="l00123"></a>00123                         a[0] = this-&gt;eleNodes[1]-&gt;Pc(0) - this-&gt;eleNodes[0]-&gt;Pc(0);
<a name="l00124"></a>00124                         a[1] = this-&gt;eleNodes[1]-&gt;Pc(1) - this-&gt;eleNodes[0]-&gt;Pc(1);
<a name="l00125"></a>00125                         a[2] = this-&gt;eleNodes[1]-&gt;Pc(2) - this-&gt;eleNodes[0]-&gt;Pc(2);
<a name="l00126"></a>00126 
<a name="l00127"></a>00127                         b[0] = this-&gt;eleNodes[2]-&gt;Pc(0) - this-&gt;eleNodes[0]-&gt;Pc(0);
<a name="l00128"></a>00128                         b[1] = this-&gt;eleNodes[2]-&gt;Pc(1) - this-&gt;eleNodes[0]-&gt;Pc(1);
<a name="l00129"></a>00129                         b[2] = this-&gt;eleNodes[2]-&gt;Pc(2) - this-&gt;eleNodes[0]-&gt;Pc(2);
<a name="l00130"></a>00130                 
<a name="l00131"></a>00131                         ar = pow((a[1]*b[2])-(a[2]*b[1]),2) + pow((a[2]*b[0])-(a[0]*b[2]),2) +  pow((a[0]*b[1])-(a[1]*b[0]),2);
<a name="l00132"></a>00132 
<a name="l00133"></a>00133                         ar = sqrt(ar)/ 2.0e+00;
<a name="l00134"></a>00134 
<a name="l00135"></a>00135                         <span class="comment">//std::cout&lt;&lt; &quot;area &quot; &lt;&lt; ar &lt;&lt; std::endl;</span>
<a name="l00136"></a>00136                         <span class="keywordflow">return</span> ar;
<a name="l00137"></a>00137                 }
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 
<a name="l00140"></a>00140                 <span class="comment">//============================================================================</span>
<a name="l00141"></a>00141                 <span class="comment">// function to return the triangle force vector resulted from surface traction</span>
<a name="l00142"></a>00142                 <span class="comment">//=============================================================================</span>
<a name="l00143"></a>00143 
<a name="l00144"></a>00144                 std::vector&lt;double&gt; getForceVec(std::vector&lt;double&gt; tr)
<a name="l00145"></a>00145                 {
<a name="l00146"></a>00146                         std::vector&lt;double&gt; triVec;      triVec.resize(9,0.0e+00);
<a name="l00147"></a>00147                         <span class="keywordtype">double</span> wa;
<a name="l00148"></a>00148                         <span class="keywordtype">int</span> ie;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150                         <span class="comment">//wa = (1.0e+00/3.0e+00)*area()/0.5e+00;    // this works as the det of the Jacobian  = area of actual/ area of reference</span>
<a name="l00151"></a>00151                         wa = (1.0e+00/3.0e+00)*area();   <span class="comment">//this is the right one because the integration wieght = (1/3) * (1/2) &quot;reference area&quot;</span>
<a name="l00152"></a>00152                         <span class="comment">//std::cout&lt;&lt; &quot;wa ====&quot; &lt;&lt; wa &lt;&lt; std::endl;</span>
<a name="l00153"></a>00153 
<a name="l00154"></a>00154                         
<a name="l00155"></a>00155                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ai = 0 ; ai &lt; 3; ai++ )             <span class="comment">// loop over the 3 triangle nodes</span>
<a name="l00156"></a>00156                         {
<a name="l00157"></a>00157                                 ie = ai*3;
<a name="l00158"></a>00158 
<a name="l00159"></a>00159                                 <span class="keywordflow">for</span>  (<span class="keywordtype">int</span> jj = 0 ; jj &lt; 3; jj++ )   <span class="comment">// loop over the 3 dofs</span>
<a name="l00160"></a>00160                                 {
<a name="l00161"></a>00161                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0 ; ii &lt; 3; ii++ )             <span class="comment">// loop over 3 Gauss points</span>
<a name="l00162"></a>00162                                         {               
<a name="l00163"></a>00163                                         triVec[ie+jj] = triVec[ie+jj] + ( wa * N[ii][ai] * tr[jj]); 
<a name="l00164"></a>00164                                         }
<a name="l00165"></a>00165                                 }
<a name="l00166"></a>00166                         }                       
<a name="l00167"></a>00167                         
<a name="l00168"></a>00168                         <span class="keywordflow">return</span> triVec;
<a name="l00169"></a>00169                 }
<a name="l00170"></a>00170                 
<a name="l00171"></a>00171                 <span class="comment">//============================================================================</span>
<a name="l00172"></a>00172                 <span class="comment">// function to return the triangle force vector resulted from infinite medium surface traction</span>
<a name="l00173"></a>00173                 <span class="comment">//=============================================================================</span>
<a name="l00174"></a>00174                 <span class="keyword">template</span> &lt;<span class="keywordtype">short</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qOrder, <span class="keyword">typename</span> T&gt;
<a name="l00175"></a>00175                 Eigen::Matrix&lt;double,dim,3&gt; getTriInfiniteForce (<span class="keyword">const</span> T* <span class="keyword">const</span> pt) {
<a name="l00176"></a>00176                   
<a name="l00177"></a>00177                   Eigen::Matrix&lt;double,dim,3&gt; tractionInt=Eigen::Matrix&lt;double,dim,3&gt;::Zero();
<a name="l00178"></a>00178                   
<a name="l00179"></a>00179                   <a class="code" href="structbvpfe_1_1_pointer_wrapper.html">PointerWrapper&lt;T&gt;</a> pts(pt);
<a name="l00180"></a>00180                   
<a name="l00181"></a>00181                   VectorDim triN = triNormal();
<a name="l00182"></a>00182                   
<a name="l00183"></a>00183                   Eigen::Matrix&lt;double,3,3&gt; tractionMatrix;
<a name="l00184"></a>00184                   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i&lt;3; i++){tractionMatrix.col(i) = this-&gt;eleNodes[i]-&gt;traction;}
<a name="l00185"></a>00185 
<a name="l00186"></a>00186                   mmdl::Quadrature&lt;2,qOrder&gt;::integrate(<span class="keyword">this</span>,tractionInt,&amp;Triangle::dislocationStressKernel&lt;<a class="code" href="structbvpfe_1_1_pointer_wrapper.html">PointerWrapper&lt;T&gt;</a> &gt; , pts, triN, tractionMatrix);
<a name="l00187"></a>00187                   
<a name="l00188"></a>00188                   <span class="keywordflow">return</span> tractionInt;
<a name="l00189"></a>00189                 }
<a name="l00190"></a>00190                 
<a name="l00191"></a>00191                 
<a name="l00192"></a>00192                 <span class="comment">//============================================================================</span>
<a name="l00193"></a>00193                 <span class="comment">// infinite medium stress integration kernel</span>
<a name="l00194"></a>00194                 <span class="comment">//=============================================================================</span>
<a name="l00195"></a>00195                 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l00196"></a>00196                 Eigen::Matrix&lt;double,dim,3&gt; dislocationStressKernel(<span class="keyword">const</span> Eigen::Matrix&lt;double,2,1&gt;&amp; Rstd, <span class="keyword">const</span> T&amp; pts, <span class="keyword">const</span> VectorDim&amp; triN, <span class="keyword">const</span> Eigen::Matrix&lt;double,3,3&gt;&amp; tractionMatrix)<span class="keyword"> const </span>{
<a name="l00197"></a>00197                         <span class="keywordtype">double</span> J ;
<a name="l00198"></a>00198                         VectorDim R=mapStdPoint&lt;2&gt;(Rstd,J);
<a name="l00199"></a>00199                         
<a name="l00200"></a>00200                         <span class="comment">//---------- interpolate externally applied traction between nodes ---------------</span>
<a name="l00201"></a>00201                         VectorDim externalTraction = VectorDim::Zero();
<a name="l00202"></a>00202                         Eigen::Matrix&lt;double,1,3&gt; shapeFunc = Shapefunc(Rstd);
<a name="l00203"></a>00203                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i&lt;3; i++){externalTraction+=shapeFunc(i)*tractionMatrix.col(i);}
<a name="l00204"></a>00204                         
<a name="l00205"></a>00205                         <span class="comment">//Eigen::Matrix&lt;double,dim,dim&gt; triStress = pts.pt-&gt;stress(R,this-&gt;sID);</span>
<a name="l00206"></a>00206                         Eigen::Matrix&lt;double,dim,dim&gt; triStress = pts.pt-&gt;stress(R);
<a name="l00207"></a>00207                             
<a name="l00208"></a>00208                         <span class="comment">//if (this-&gt;sID==428||this-&gt;sID==471||this-&gt;sID==1895||this-&gt;sID==1899||this-&gt;sID==1898||this-&gt;sID==442||this-&gt;sID==805) {</span>
<a name="l00209"></a>00209                         <span class="comment">/*if (this-&gt;sID==26||this-&gt;sID==457||this-&gt;sID==927||this-&gt;sID==456||this-&gt;sID==935 </span>
<a name="l00210"></a>00210 <span class="comment">                            || this-&gt;sID==428||this-&gt;sID==471||this-&gt;sID==1895||this-&gt;sID==1899||this-&gt;sID==1898||this-&gt;sID==442||this-&gt;sID==805) {</span>
<a name="l00211"></a>00211 <span class="comment">                          std::cout&lt;&lt; this-&gt;sID &lt;&lt; &quot; : &quot;&lt;&lt; triStress.col(0).transpose() &lt;&lt; &quot; &quot; &lt;&lt;triStress.col(1).transpose() &lt;&lt; &quot; &quot; &lt;&lt;triStress.col(2).transpose() &lt;&lt;std::endl;  </span>
<a name="l00212"></a>00212 <span class="comment">                        }*/</span>
<a name="l00213"></a>00213                         <span class="keywordflow">return</span> (externalTraction-(triStress*triN))*shapeFunc*J ;
<a name="l00214"></a>00214                         <span class="comment">//return (externalTraction-(pts.pt-&gt;stress(R,this-&gt;sID)*triN))*shapeFunc*J ;</span>
<a name="l00215"></a>00215                 
<a name="l00216"></a>00216                 }
<a name="l00217"></a>00217                 
<a name="l00218"></a>00218                 <span class="comment">//==============================================================================</span>
<a name="l00219"></a>00219                 <span class="comment">// function to map the Gauss point to the actual domain</span>
<a name="l00220"></a>00220                 <span class="comment">//==============================================================================</span>
<a name="l00221"></a>00221                 <span class="keyword">template</span>&lt;<span class="keywordtype">short</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> OtherDim&gt;
<a name="l00222"></a>00222                 VectorDim mapStdPoint(<span class="keyword">const</span> Eigen::Matrix&lt;double,2,1&gt;&amp; Rstd, <span class="keywordtype">double</span>&amp; J)<span class="keyword"> const </span>{
<a name="l00223"></a>00223                         
<a name="l00224"></a>00224                   Eigen::Matrix&lt;double,dim,OtherDim&gt; A;
<a name="l00225"></a>00225                   VectorDim b = this-&gt;eleNodes[0]-&gt;P;
<a name="l00226"></a>00226                   
<a name="l00227"></a>00227                   Eigen::Matrix&lt;double,dim,1&gt; temp;
<a name="l00228"></a>00228                   
<a name="l00229"></a>00229                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i&lt;OtherDim; i++){
<a name="l00230"></a>00230                                 A.col(i) = this-&gt;eleNodes[i+1]-&gt;P - this-&gt;eleNodes[0]-&gt;P;
<a name="l00231"></a>00231                     }
<a name="l00232"></a>00232                 
<a name="l00233"></a>00233                     temp = A.col(0).cross(A.col(1));
<a name="l00234"></a>00234                     J= temp.norm();    <span class="comment">// this is = area of actual triangle * 2 , but the sum of integration weights for triangle is actually in this code (1/2)               </span>
<a name="l00235"></a>00235                     
<a name="l00236"></a>00236                     assert(J&gt;0.0);
<a name="l00237"></a>00237                     <span class="keywordflow">return</span>  A * Rstd +b ; 
<a name="l00238"></a>00238                 }
<a name="l00239"></a>00239                 
<a name="l00240"></a>00240                 <span class="comment">//================================================================================</span>
<a name="l00241"></a>00241                 <span class="comment">// function to return the unit vector normal to the triangle</span>
<a name="l00242"></a>00242                 <span class="comment">//=================================================================================</span>
<a name="l00243"></a>00243                 
<a name="l00244"></a>00244                 VectorDim triNormal ()
<a name="l00245"></a>00245                 {
<a name="l00246"></a>00246                   VectorDim n, v1 , v2;
<a name="l00247"></a>00247                   
<a name="l00248"></a>00248                   v1 = this-&gt;eleNodes[1]-&gt;P - this-&gt;eleNodes[0]-&gt;P;
<a name="l00249"></a>00249                   v2 = this-&gt;eleNodes[2]-&gt;P - this-&gt;eleNodes[0]-&gt;P;
<a name="l00250"></a>00250                   
<a name="l00251"></a>00251                   n = v2.cross(v1);
<a name="l00252"></a>00252                   
<a name="l00253"></a>00253                   <span class="keywordflow">return</span> n.normalized();
<a name="l00254"></a>00254                 }
<a name="l00255"></a>00255                 
<a name="l00256"></a>00256                 <span class="comment">//================================================================================</span>
<a name="l00257"></a>00257                 <span class="comment">// function to return the unit vector normal to the triangle in deformed configuration</span>
<a name="l00258"></a>00258                 <span class="comment">//=================================================================================</span>
<a name="l00259"></a>00259                 
<a name="l00260"></a>00260                 VectorDim triNormalDeformed()<span class="keyword"> const</span>
<a name="l00261"></a>00261 <span class="keyword">                </span>{
<a name="l00262"></a>00262                   VectorDim n, v1 , v2;
<a name="l00263"></a>00263                   
<a name="l00264"></a>00264                   v1 = this-&gt;eleNodes[1]-&gt;Pc - this-&gt;eleNodes[0]-&gt;Pc;
<a name="l00265"></a>00265                   v2 = this-&gt;eleNodes[2]-&gt;Pc - this-&gt;eleNodes[0]-&gt;Pc;
<a name="l00266"></a>00266                   
<a name="l00267"></a>00267                   n = v2.cross(v1);
<a name="l00268"></a>00268                   
<a name="l00269"></a>00269                   <span class="keywordflow">return</span> n.normalized();
<a name="l00270"></a>00270                 }
<a name="l00271"></a>00271                 <span class="comment">//================================================================================</span>
<a name="l00272"></a>00272                 <span class="comment">// function to return the 3 shape functions at any reference point</span>
<a name="l00273"></a>00273                 <span class="comment">//=================================================================================</span>
<a name="l00274"></a>00274                 
<a name="l00275"></a>00275                 Eigen::Matrix&lt;double,1,3&gt; Shapefunc (Eigen::Matrix&lt;double,2,1&gt; Rstd)<span class="keyword"> const </span>{
<a name="l00276"></a>00276                   Eigen::Matrix&lt;double,1,3&gt; sf;
<a name="l00277"></a>00277                   
<a name="l00278"></a>00278                       sf(0) = 1.0 - Rstd(0) - Rstd(1);
<a name="l00279"></a>00279                       sf(1) = Rstd(0);
<a name="l00280"></a>00280                       sf(2) = Rstd(1);
<a name="l00281"></a>00281                         
<a name="l00282"></a>00282                   <span class="keywordflow">return</span> sf;
<a name="l00283"></a>00283                 }
<a name="l00284"></a>00284                 
<a name="l00285"></a>00285                 <span class="comment">//================================================================================</span>
<a name="l00286"></a>00286                 <span class="comment">// function to return the shape function for node (in) at any reference point</span>
<a name="l00287"></a>00287                 <span class="comment">//=================================================================================</span>
<a name="l00288"></a>00288                 
<a name="l00289"></a>00289                 <span class="keywordtype">double</span> Shapefunc_i (Eigen::Matrix&lt;double,2,1&gt; Rstd , <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> in)
<a name="l00290"></a>00290                 {
<a name="l00291"></a>00291                   <span class="keywordtype">double</span> sf;
<a name="l00292"></a>00292                   
<a name="l00293"></a>00293                   <span class="keywordflow">switch</span> (in){
<a name="l00294"></a>00294                     <span class="keywordflow">case</span> 0:
<a name="l00295"></a>00295                       sf = 1.0 - Rstd(0) - Rstd(1);    <span class="keywordflow">break</span>;
<a name="l00296"></a>00296                     <span class="keywordflow">case</span> 1:
<a name="l00297"></a>00297                       sf = Rstd(0);                    <span class="keywordflow">break</span>;
<a name="l00298"></a>00298                     <span class="keywordflow">case</span> 2:
<a name="l00299"></a>00299                       sf = Rstd(1);                    <span class="keywordflow">break</span>;
<a name="l00300"></a>00300                   }               
<a name="l00301"></a>00301                   <span class="keywordflow">return</span> sf;
<a name="l00302"></a>00302                 }
<a name="l00303"></a>00303                 
<a name="l00304"></a>00304                 <span class="comment">//=====================================================================================================</span>
<a name="l00305"></a>00305                 <span class="comment">// function to check if a given line lies on one of the triangle edges or not</span>
<a name="l00306"></a>00306                 <span class="comment">//=====================================================================================================</span>
<a name="l00307"></a>00307                 
<a name="l00308"></a>00308                 <span class="keywordtype">bool</span> onTriEdge (std::pair&lt;VectorDim,VectorDim&gt; lineP) {
<a name="l00309"></a>00309                   VectorDim p1 = lineP.first;
<a name="l00310"></a>00310                   VectorDim p2 = lineP.second;
<a name="l00311"></a>00311                   
<a name="l00312"></a>00312                   <span class="keywordtype">double</span> tol  = edgeTol;
<a name="l00313"></a>00313                   
<a name="l00314"></a>00314                   <span class="keywordflow">return</span> ( ((p1-this-&gt;eleNodes[0]-&gt;P).norm() &lt; tol || (p1-this-&gt;eleNodes[1]-&gt;P).norm() &lt; tol || (p1-this-&gt;eleNodes[2]-&gt;P).norm() &lt; tol) &amp;&amp; 
<a name="l00315"></a>00315                            ((p2-this-&gt;eleNodes[0]-&gt;P).norm() &lt; tol || (p2-this-&gt;eleNodes[1]-&gt;P).norm() &lt; tol || (p2-this-&gt;eleNodes[2]-&gt;P).norm() &lt; tol)    );
<a name="l00316"></a>00316                   
<a name="l00317"></a>00317                 }
<a name="l00318"></a>00318                 
<a name="l00319"></a>00319                 
<a name="l00320"></a>00320                 <span class="comment">//======================================================================================================</span>
<a name="l00321"></a>00321                 <span class="comment">// function to find the 2D projection plane for the triangle. On this plane, the Barycentric coordinates</span>
<a name="l00322"></a>00322                 <span class="comment">// in 2D will be calculated. If the returned values ix = 2 , iy = 3 so the projection plane is y-z plane</span>
<a name="l00323"></a>00323                 <span class="comment">//=======================================================================================================</span>
<a name="l00324"></a>00324                 Eigen::Matrix&lt;unsigned int,2,1&gt; find2DProjectionPlane()<span class="keyword"> const</span>{
<a name="l00325"></a>00325                   
<a name="l00326"></a>00326                   VectorDim uV;
<a name="l00327"></a>00327                   std::vector&lt;int&gt; normal , not_normal;
<a name="l00328"></a>00328                   Eigen::Matrix&lt;unsigned int,2,1&gt; ppindx;
<a name="l00329"></a>00329                   
<a name="l00330"></a>00330                   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;3; i++){
<a name="l00331"></a>00331                     uV = VectorDim::Zero();     uV(i) = 1.0;
<a name="l00332"></a>00332                     <span class="keywordflow">if</span>(std::abs(uV.dot(outNormal)) &lt; 0.15e00){     <span class="comment">// the plane normal makes angle of &gt; 80 degrees with direction x_i</span>
<a name="l00333"></a>00333                       normal.push_back(i);
<a name="l00334"></a>00334                     }
<a name="l00335"></a>00335                     <span class="keywordflow">else</span>{not_normal.push_back(i);}
<a name="l00336"></a>00336                   }
<a name="l00337"></a>00337                   
<a name="l00338"></a>00338                   <span class="keywordflow">switch</span> (normal.size()){
<a name="l00339"></a>00339                     <span class="keywordflow">case</span> 2:
<a name="l00340"></a>00340                       ppindx(0) = normal[0];
<a name="l00341"></a>00341                       ppindx(1) = normal[1];
<a name="l00342"></a>00342                       <span class="keywordflow">break</span>;
<a name="l00343"></a>00343                     <span class="keywordflow">case</span> 1:
<a name="l00344"></a>00344                       ppindx(0) = normal[0];
<a name="l00345"></a>00345                       ppindx(1) = not_normal[0];
<a name="l00346"></a>00346                       <span class="keywordflow">break</span>;
<a name="l00347"></a>00347                     <span class="keywordflow">case</span> 0:
<a name="l00348"></a>00348                       ppindx(0) = not_normal[0];
<a name="l00349"></a>00349                       ppindx(1) = not_normal[1];
<a name="l00350"></a>00350                       <span class="keywordflow">break</span>;
<a name="l00351"></a>00351                   }
<a name="l00352"></a>00352                   <span class="keywordflow">return</span> ppindx;
<a name="l00353"></a>00353                 }
<a name="l00354"></a>00354                 
<a name="l00355"></a>00355                 <span class="comment">//================================================================================</span>
<a name="l00356"></a>00356                 <span class="comment">// function to find the intersection between triangle edges and a line (if any)</span>
<a name="l00357"></a>00357                 <span class="comment">//================================================================================</span>
<a name="l00358"></a>00358                 
<a name="l00359"></a>00359                 <span class="keywordtype">bool</span> intersectWithLine (VectorDim p0 , VectorDim p1 , VectorDim &amp; P ,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp; indx ){
<a name="l00360"></a>00360                   
<a name="l00361"></a>00361                   <span class="comment">//------------- find plane of projection during intersection calculation -------</span>
<a name="l00362"></a>00362                   
<a name="l00363"></a>00363                   <span class="comment">//VectorDim uV;</span>
<a name="l00364"></a>00364                   <span class="comment">//double tol = 1.0e-08;</span>
<a name="l00365"></a>00365                   <span class="comment">//int ix , iy;</span>
<a name="l00366"></a>00366                   <span class="comment">//ix = 0;   iy = 0;</span>
<a name="l00367"></a>00367                   
<a name="l00368"></a>00368                   Eigen::Matrix&lt;unsigned int,2,1&gt; ppindx= find2DProjectionPlane();
<a name="l00369"></a>00369                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ix = ppindx(0);
<a name="l00370"></a>00370                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iy = ppindx(1);
<a name="l00371"></a>00371                   <span class="comment">/*</span>
<a name="l00372"></a>00372 <span class="comment">                  std::vector&lt;int&gt; normal , not_normal;</span>
<a name="l00373"></a>00373 <span class="comment">                  </span>
<a name="l00374"></a>00374 <span class="comment">                  for(int i=0; i&lt;3; i++){</span>
<a name="l00375"></a>00375 <span class="comment">                    uV = VectorDim::Zero();     uV(i) = 1.0;</span>
<a name="l00376"></a>00376 <span class="comment">                    if(std::abs(uV.dot(outNormal)) &lt; 0.15e00){     // the plane normal makes angle of &gt; 80 degrees with direction x_i</span>
<a name="l00377"></a>00377 <span class="comment">                      normal.push_back(i);</span>
<a name="l00378"></a>00378 <span class="comment">                    }</span>
<a name="l00379"></a>00379 <span class="comment">                    else{not_normal.push_back(i);}</span>
<a name="l00380"></a>00380 <span class="comment">                  }</span>
<a name="l00381"></a>00381 <span class="comment">                  </span>
<a name="l00382"></a>00382 <span class="comment">                  switch (normal.size()){</span>
<a name="l00383"></a>00383 <span class="comment">                    case 2:</span>
<a name="l00384"></a>00384 <span class="comment">                      ix = normal[0];</span>
<a name="l00385"></a>00385 <span class="comment">                      iy = normal[1];</span>
<a name="l00386"></a>00386 <span class="comment">                      break;</span>
<a name="l00387"></a>00387 <span class="comment">                    case 1:</span>
<a name="l00388"></a>00388 <span class="comment">                      ix = normal[0];</span>
<a name="l00389"></a>00389 <span class="comment">                      iy = not_normal[0];</span>
<a name="l00390"></a>00390 <span class="comment">                      break;</span>
<a name="l00391"></a>00391 <span class="comment">                    case 0:</span>
<a name="l00392"></a>00392 <span class="comment">                      ix = not_normal[0];</span>
<a name="l00393"></a>00393 <span class="comment">                      iy = not_normal[1];</span>
<a name="l00394"></a>00394 <span class="comment">                      break;</span>
<a name="l00395"></a>00395 <span class="comment">                  }</span>
<a name="l00396"></a>00396 <span class="comment">                  */</span>
<a name="l00397"></a>00397                   <span class="comment">//--------------- calculate barycentric coordinates of the node -----------</span>
<a name="l00398"></a>00398                   
<a name="l00399"></a>00399                   <span class="keywordtype">bool</span> found= <span class="keyword">false</span>;;
<a name="l00400"></a>00400                   
<a name="l00401"></a>00401                   Eigen::Matrix&lt;double,3,1&gt;::Index ii;
<a name="l00402"></a>00402                   Eigen::Matrix&lt;double,3,1&gt; Bary = getBarycentric(p1 , ix , iy);
<a name="l00403"></a>00403                   <span class="keywordtype">double</span> baryMin = Bary.minCoeff(&amp;ii);
<a name="l00404"></a>00404                   
<a name="l00405"></a>00405                   <span class="keywordflow">if</span>(baryMin &gt; 0.0 &amp;&amp; baryMin &lt; 1.0 ){
<a name="l00406"></a>00406                     <span class="comment">//-- NO intersection, new point is on the same triangle ----------</span>
<a name="l00407"></a>00407                     <span class="comment">//found = false;</span>
<a name="l00408"></a>00408                     P = p1;
<a name="l00409"></a>00409                   }
<a name="l00410"></a>00410                   <span class="keywordflow">else</span>{
<a name="l00411"></a>00411                     <span class="comment">//------------------ implement intersection  with the 3 triangle edges -----------</span>
<a name="l00412"></a>00412                     VectorDim x0 , x1 , pP1;
<a name="l00413"></a>00413                     Eigen::Matrix&lt;double,2,2&gt; mat;
<a name="l00414"></a>00414                     Eigen::Matrix&lt;double,2,1&gt; u,b;
<a name="l00415"></a>00415                     
<a name="l00416"></a>00416                     std::vector&lt;VectorDim&gt; intersectionPoints;
<a name="l00417"></a>00417                     std::vector&lt;unsigned int&gt; sideID;
<a name="l00418"></a>00418                     VectorDim temp;
<a name="l00419"></a>00419                     
<a name="l00420"></a>00420                     <span class="comment">//pP1 = p0 + 4.0e00*(p1-p0);             // extend the line to avoid the effect of any errors on the calculation</span>
<a name="l00421"></a>00421                     pP1 = p1;
<a name="l00422"></a>00422                     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;3; i++){               <span class="comment">// loop over the 3 triangle edges</span>
<a name="l00423"></a>00423                       x0 = this-&gt;eleNodes[(i+1)%3]-&gt;P;
<a name="l00424"></a>00424                       x1 = this-&gt;eleNodes[(i+2)%3]-&gt;P;
<a name="l00425"></a>00425                     
<a name="l00426"></a>00426                       mat(0,0) = pP1(ix) - p0(ix);        mat(0,1) = x0(ix) - x1(ix);    
<a name="l00427"></a>00427                       mat(1,0) = pP1(iy) - p0(iy);        mat(1,1) = x0(iy) - x1(iy);
<a name="l00428"></a>00428                     
<a name="l00429"></a>00429                       b(0) = x0(ix) - p0(ix);
<a name="l00430"></a>00430                       b(1) = x0(iy) - p0(iy);
<a name="l00431"></a>00431                     
<a name="l00432"></a>00432                       u = mat.inverse()*b;
<a name="l00433"></a>00433                     
<a name="l00434"></a>00434                       <span class="keywordflow">if</span> ( <span class="comment">/*u(0) &gt; 1.0e-2 &amp;&amp; u(0) &lt;=1.0e00 &amp;&amp;*/</span> u(1) &gt;= 0.0e00  &amp;&amp; u(1) &lt;=1.0e00) {       <span class="comment">// intersection point is within the triangle line segments</span>
<a name="l00435"></a>00435                         temp = x0 + u(1)*(x1-x0);
<a name="l00436"></a>00436                         intersectionPoints.push_back(temp);
<a name="l00437"></a>00437                         sideID.push_back(i);
<a name="l00438"></a>00438                         <span class="comment">//P = p0 + u(0)*(pP1-p0);</span>
<a name="l00439"></a>00439                         <span class="comment">/*</span>
<a name="l00440"></a>00440 <span class="comment">                        P = x0 + u(1)*(x1-x0);</span>
<a name="l00441"></a>00441 <span class="comment">                        found = true;</span>
<a name="l00442"></a>00442 <span class="comment">                        indx = neighbor[i]-&gt;sID;</span>
<a name="l00443"></a>00443 <span class="comment">                        break;</span>
<a name="l00444"></a>00444 <span class="comment">                        */</span>
<a name="l00445"></a>00445                       }
<a name="l00446"></a>00446                     }
<a name="l00447"></a>00447                       
<a name="l00448"></a>00448                     <span class="keywordflow">if</span>(intersectionPoints.size()==0) {
<a name="l00449"></a>00449                       std::cout &lt;&lt; <span class="stringliteral">&quot;Old position &quot;</span> &lt;&lt;std::setprecision(15) &lt;&lt;  p0.transpose() &lt;&lt; std::endl;
<a name="l00450"></a>00450                       std::cout &lt;&lt; <span class="stringliteral">&quot;New position &quot;</span> &lt;&lt;std::setprecision(15) &lt;&lt;  p1.transpose() &lt;&lt; std::endl;
<a name="l00451"></a>00451                       std::cout &lt;&lt; <span class="stringliteral">&quot;Traingel ID  &quot;</span> &lt;&lt; this-&gt;sID &lt;&lt; std::endl;
<a name="l00452"></a>00452                       assert(0 &amp;&amp; <span class="stringliteral">&quot;Failed to calculate new position for a moving boundary node&quot;</span>);
<a name="l00453"></a>00453                     }
<a name="l00454"></a>00454                     
<a name="l00455"></a>00455                     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(intersectionPoints.size()==1){
<a name="l00456"></a>00456                       P = intersectionPoints[0];
<a name="l00457"></a>00457                       found = <span class="keyword">true</span>;
<a name="l00458"></a>00458                       indx = neighbor[sideID[0]]-&gt;sID;
<a name="l00459"></a>00459                     }
<a name="l00460"></a>00460                     
<a name="l00461"></a>00461                     <span class="keywordflow">else</span> {    <span class="comment">// found 2 or 3 intersection points</span>
<a name="l00462"></a>00462                       
<a name="l00463"></a>00463                       <span class="comment">//----------- check which of them is closure to the point p1</span>
<a name="l00464"></a>00464                       <span class="keywordtype">double</span> minDis = 1.0e20;
<a name="l00465"></a>00465                       <span class="keywordtype">int</span> ii = -1;
<a name="l00466"></a>00466                       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i1=0; i1&lt;intersectionPoints.size();i1++){
<a name="l00467"></a>00467                         <span class="keywordflow">if</span> ((intersectionPoints[i1]-p1).norm() &lt; minDis){
<a name="l00468"></a>00468                           ii = i1;
<a name="l00469"></a>00469                           minDis = (intersectionPoints[i1]-p1).norm();
<a name="l00470"></a>00470                         }
<a name="l00471"></a>00471                       }
<a name="l00472"></a>00472                       
<a name="l00473"></a>00473                       P = intersectionPoints[ii];
<a name="l00474"></a>00474                       found = <span class="keyword">true</span>;
<a name="l00475"></a>00475                       indx = neighbor[sideID[ii]]-&gt;sID;
<a name="l00476"></a>00476                       
<a name="l00477"></a>00477                       <span class="comment">/*</span>
<a name="l00478"></a>00478 <span class="comment">                      int repeatedPoint = -1; </span>
<a name="l00479"></a>00479 <span class="comment">                      for (unsigned int i1=0; i1&lt;intersectionPoints.size();i1++){</span>
<a name="l00480"></a>00480 <span class="comment">                        for (unsigned int i2=i1+1; i2&lt;intersectionPoints.size(); i2++){</span>
<a name="l00481"></a>00481 <span class="comment">                          if (std::abs(intersectionPoints[i1].dot(intersectionPoints[i2])) &lt; 1.0e-12 ) repeatedPoint = i1; </span>
<a name="l00482"></a>00482 <span class="comment">                        }</span>
<a name="l00483"></a>00483 <span class="comment">                      }</span>
<a name="l00484"></a>00484 <span class="comment">                </span>
<a name="l00485"></a>00485 <span class="comment">                      if (repeatedPoint != -1) intersectionPoints.erase(intersectionPoints.begin()+repeatedPoint);</span>
<a name="l00486"></a>00486 <span class="comment">                      */</span>
<a name="l00487"></a>00487                       
<a name="l00488"></a>00488                       
<a name="l00489"></a>00489                     }
<a name="l00490"></a>00490                       
<a name="l00491"></a>00491                     <span class="keywordflow">if</span> (!found) {
<a name="l00492"></a>00492                       std::cout &lt;&lt; <span class="stringliteral">&quot;Old position &quot;</span> &lt;&lt;std::setprecision(15) &lt;&lt;  p0.transpose() &lt;&lt; std::endl;
<a name="l00493"></a>00493                       std::cout &lt;&lt; <span class="stringliteral">&quot;New position &quot;</span> &lt;&lt;std::setprecision(15) &lt;&lt;  p1.transpose() &lt;&lt; std::endl;
<a name="l00494"></a>00494                       std::cout &lt;&lt; <span class="stringliteral">&quot;Traingel ID  &quot;</span> &lt;&lt; this-&gt;sID &lt;&lt; std::endl;
<a name="l00495"></a>00495                       assert(0 &amp;&amp; <span class="stringliteral">&quot;Failed to calculate new position for a moving boundary node&quot;</span>);
<a name="l00496"></a>00496                     }
<a name="l00497"></a>00497                   }
<a name="l00498"></a>00498                   
<a name="l00499"></a>00499                   <span class="keywordflow">return</span> found;
<a name="l00500"></a>00500                 }
<a name="l00501"></a>00501                 
<a name="l00502"></a>00502                 <span class="comment">//==================================================================================</span>
<a name="l00503"></a>00503                 <span class="comment">// Function to split this triangle into 3 subtriangles, given the intersection line between the triangle and a segment&#39;s glide plane</span>
<a name="l00504"></a>00504                 <span class="comment">//===================================================================================</span>
<a name="l00505"></a>00505                 
<a name="l00506"></a>00506                 std::vector&lt;Eigen::Matrix&lt;double,dim,dim&gt; &gt; spliteTriangle (std::pair&lt;VectorDim,VectorDim&gt; glidePlaneLine) {
<a name="l00507"></a>00507                   
<a name="l00508"></a>00508                   std::vector&lt;Eigen::Matrix&lt;double,dim,dim&gt; &gt; trisPointsSet;
<a name="l00509"></a>00509                   Eigen::Matrix&lt;double,dim,dim&gt; trisPoint;
<a name="l00510"></a>00510                   
<a name="l00511"></a>00511                   std::vector&lt;std::pair&lt;VectorDim,unsigned int&gt; &gt;edgePoints;
<a name="l00512"></a>00512                   std::vector&lt;std::pair&lt;VectorDim,unsigned int&gt; &gt;vertexPoints;
<a name="l00513"></a>00513                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> in;
<a name="l00514"></a>00514                   
<a name="l00515"></a>00515                   <span class="keywordflow">if</span> (isPointOnVertex(glidePlaneLine.first, in)) vertexPoints.push_back(std::make_pair(glidePlaneLine.first, in));
<a name="l00516"></a>00516                   <span class="keywordflow">else</span> edgePoints.push_back(std::make_pair(glidePlaneLine.first, in));
<a name="l00517"></a>00517                   
<a name="l00518"></a>00518                   <span class="keywordflow">if</span> (isPointOnVertex(glidePlaneLine.second, in)) vertexPoints.push_back(std::make_pair(glidePlaneLine.second, in));
<a name="l00519"></a>00519                   <span class="keywordflow">else</span> edgePoints.push_back(std::make_pair(glidePlaneLine.second, in));
<a name="l00520"></a>00520                     
<a name="l00521"></a>00521                   <span class="comment">// if one point on a vertex and the other on an edge that is connected to the same vertex, so the line is almost on an edge -&gt; no splitting</span>
<a name="l00522"></a>00522                   <span class="keywordflow">if</span> (edgePoints.size()==1 &amp;&amp; vertexPoints.size()==1 &amp;&amp; edgePoints[0].second != vertexPoints[0].second ) edgePoints.clear();   
<a name="l00523"></a>00523                     
<a name="l00524"></a>00524                   
<a name="l00525"></a>00525                   std::vector&lt;unsigned int&gt; otherVertexes;
<a name="l00526"></a>00526                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> otherVertex = 5;       <span class="comment">// dummy initialization, just to avoid getting warning</span>
<a name="l00527"></a>00527                   
<a name="l00528"></a>00528                   <span class="keywordflow">switch</span> (edgePoints.size()){
<a name="l00529"></a>00529                     <span class="keywordflow">case</span> 0:          <span class="comment">// both points are on vertexes, no spliting</span>
<a name="l00530"></a>00530                       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;3;i++) trisPoint.col(i) = this-&gt;eleNodes[i]-&gt;P;
<a name="l00531"></a>00531                       trisPointsSet.push_back(trisPoint);
<a name="l00532"></a>00532                       <span class="keywordflow">break</span>;
<a name="l00533"></a>00533                       
<a name="l00534"></a>00534                     <span class="keywordflow">case</span> 1:         <span class="comment">// one point on a vertex and the other point on an edge, split into only two triangles</span>
<a name="l00535"></a>00535                       
<a name="l00536"></a>00536                       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;3;i++) {<span class="keywordflow">if</span> (i!=vertexPoints[0].second) otherVertexes.push_back(i);}
<a name="l00537"></a>00537                       <span class="comment">//---- triangle 1 ----</span>
<a name="l00538"></a>00538                       trisPoint.col(0) = this-&gt;eleNodes[vertexPoints[0].second]-&gt;P;
<a name="l00539"></a>00539                       trisPoint.col(1) = edgePoints[0].first;
<a name="l00540"></a>00540                       trisPoint.col(2) = this-&gt;eleNodes[otherVertexes[0]]-&gt;P;
<a name="l00541"></a>00541                       trisPointsSet.push_back(trisPoint);
<a name="l00542"></a>00542                       
<a name="l00543"></a>00543                       <span class="comment">//---- triangle 2 ----</span>
<a name="l00544"></a>00544                       trisPoint.col(0) = this-&gt;eleNodes[vertexPoints[0].second]-&gt;P;
<a name="l00545"></a>00545                       trisPoint.col(1) = edgePoints[0].first;
<a name="l00546"></a>00546                       trisPoint.col(2) = this-&gt;eleNodes[otherVertexes[1]]-&gt;P;
<a name="l00547"></a>00547                       trisPointsSet.push_back(trisPoint);
<a name="l00548"></a>00548                       <span class="keywordflow">break</span>;
<a name="l00549"></a>00549                       
<a name="l00550"></a>00550                     <span class="keywordflow">case</span> 2:   <span class="comment">// two points on edges -&gt; split into 3 triangles</span>
<a name="l00551"></a>00551                       
<a name="l00552"></a>00552                       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;3;i++) {<span class="keywordflow">if</span> (i!=edgePoints[0].second &amp;&amp; i!=edgePoints[1].second) otherVertex=i;}
<a name="l00553"></a>00553                       
<a name="l00554"></a>00554                       <span class="comment">//---- triangle 1 ----</span>
<a name="l00555"></a>00555                       trisPoint.col(0) = edgePoints[0].first;
<a name="l00556"></a>00556                       trisPoint.col(1) = edgePoints[1].first;
<a name="l00557"></a>00557                       trisPoint.col(2) = this-&gt;eleNodes[otherVertex]-&gt;P;
<a name="l00558"></a>00558                       trisPointsSet.push_back(trisPoint);
<a name="l00559"></a>00559                       
<a name="l00560"></a>00560                       <span class="comment">//---- triangle 2 ----</span>
<a name="l00561"></a>00561                       trisPoint.col(0) = edgePoints[0].first;
<a name="l00562"></a>00562                       trisPoint.col(1) = edgePoints[1].first;
<a name="l00563"></a>00563                       trisPoint.col(2) = this-&gt;eleNodes[edgePoints[0].second]-&gt;P;
<a name="l00564"></a>00564                       trisPointsSet.push_back(trisPoint);
<a name="l00565"></a>00565                       
<a name="l00566"></a>00566                       <span class="comment">//---- triangle 2 ----</span>
<a name="l00567"></a>00567                       trisPoint.col(0) = edgePoints[0].first;
<a name="l00568"></a>00568                       trisPoint.col(1) = this-&gt;eleNodes[edgePoints[0].second]-&gt;P;
<a name="l00569"></a>00569                       trisPoint.col(2) = this-&gt;eleNodes[edgePoints[1].second]-&gt;P;
<a name="l00570"></a>00570                       trisPointsSet.push_back(trisPoint);
<a name="l00571"></a>00571                       <span class="keywordflow">break</span>;
<a name="l00572"></a>00572                       
<a name="l00573"></a>00573                     <span class="keywordflow">default</span>:
<a name="l00574"></a>00574                       assert(0 &amp;&amp; <span class="stringliteral">&quot; Error in Trianlge.h::spliteTriangle function &quot;</span> );
<a name="l00575"></a>00575                       
<a name="l00576"></a>00576                   }
<a name="l00577"></a>00577                                   
<a name="l00578"></a>00578                   <span class="keywordflow">return</span> trisPointsSet;
<a name="l00579"></a>00579                 }
<a name="l00580"></a>00580                 
<a name="l00581"></a>00581                 <span class="comment">//======================================================================================================</span>
<a name="l00582"></a>00582                 <span class="comment">// function to check if a point is on one of the triangle vertexes, and updates the index of this vertex,</span>
<a name="l00583"></a>00583                 <span class="comment">// or if it is on the edge, it update the edge index (which is the index of the corresponding vertex)</span>
<a name="l00584"></a>00584                 <span class="comment">//======================================================================================================</span>
<a name="l00585"></a>00585                 
<a name="l00586"></a>00586                 <span class="keywordtype">bool</span> isPointOnVertex (VectorDim P, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp; in) {
<a name="l00587"></a>00587                   <span class="keywordtype">bool</span> onVertex = <span class="keyword">false</span>;
<a name="l00588"></a>00588                   
<a name="l00589"></a>00589                   <span class="comment">//----- check if the intersection point is on a vertex ----</span>
<a name="l00590"></a>00590                   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;3; i++){               <span class="comment">// loop over the 3 triangle edges</span>
<a name="l00591"></a>00591                     <span class="keywordflow">if</span> ((P-this-&gt;eleNodes[i]-&gt;P).norm() &lt; edgeTol) {
<a name="l00592"></a>00592                       in= i;
<a name="l00593"></a>00593                       onVertex = <span class="keyword">true</span>;
<a name="l00594"></a>00594                       <span class="keywordflow">break</span>;
<a name="l00595"></a>00595                     }
<a name="l00596"></a>00596                   }
<a name="l00597"></a>00597                   
<a name="l00598"></a>00598                   <span class="keywordflow">if</span> (!onVertex) in = findEdgeIndex(P);
<a name="l00599"></a>00599                   
<a name="l00600"></a>00600                   <span class="keywordflow">return</span> onVertex;
<a name="l00601"></a>00601                 }
<a name="l00602"></a>00602                 
<a name="l00603"></a>00603                 <span class="comment">//==============================================================================</span>
<a name="l00604"></a>00604                 <span class="comment">// function to return the index of the triangle edge on which the intersection point is on.</span>
<a name="l00605"></a>00605                 <span class="comment">// if the line cuts the triangle in vertex, the function returns a number &gt; 2 (10 for example)</span>
<a name="l00606"></a>00606                 <span class="comment">//==============================================================================</span>
<a name="l00607"></a>00607                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> findEdgeIndex (VectorDim P) {
<a name="l00608"></a>00608                   
<a name="l00609"></a>00609                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii;
<a name="l00610"></a>00610                   VectorDim x0 , x1;
<a name="l00611"></a>00611 
<a name="l00612"></a>00612                   VectorDim crossProduct;
<a name="l00613"></a>00613                   
<a name="l00614"></a>00614                   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;3; i++){               <span class="comment">// loop over the 3 triangle edges</span>
<a name="l00615"></a>00615                     x0 = this-&gt;eleNodes[(i+1)%3]-&gt;P;
<a name="l00616"></a>00616                     x1 = this-&gt;eleNodes[(i+2)%3]-&gt;P;
<a name="l00617"></a>00617                     crossProduct(i) = ( (P-x0).cross(P-x1) ).norm();
<a name="l00618"></a>00618                   }
<a name="l00619"></a>00619 
<a name="l00620"></a>00620                   Eigen::Matrix&lt;double,3,1&gt;::Index in;
<a name="l00621"></a>00621                   <span class="keywordtype">double</span> cP_min = crossProduct.minCoeff(&amp;in);
<a name="l00622"></a>00622                   assert(cP_min&lt;0.01&amp;&amp;<span class="stringliteral">&quot;error on getting the triangle edge on which an intersection point is on:: Triangle.h::findEdgeIndex (VectorDim P)&quot;</span>);
<a name="l00623"></a>00623 
<a name="l00624"></a>00624                   ii = in;
<a name="l00625"></a>00625 
<a name="l00626"></a>00626                   <span class="keywordflow">return</span> ii;
<a name="l00627"></a>00627                 }
<a name="l00628"></a>00628                 
<a name="l00629"></a>00629                 <span class="comment">/*</span>
<a name="l00630"></a>00630 <span class="comment">                //============================================================================</span>
<a name="l00631"></a>00631 <span class="comment">                // function to return the triangle force vector resulted from infinite medium surface traction of a single dislocation segment</span>
<a name="l00632"></a>00632 <span class="comment">                //=============================================================================</span>
<a name="l00633"></a>00633 <span class="comment">                template &lt; typename T&gt;</span>
<a name="l00634"></a>00634 <span class="comment">                Eigen::Matrix&lt;double,dim,3&gt; getTriInfiniteForce_Seg (const T* const pt, const unsigned int iSeg) {</span>
<a name="l00635"></a>00635 <span class="comment">                  </span>
<a name="l00636"></a>00636 <span class="comment">                  Eigen::Matrix&lt;double,dim,3&gt; tractionInt=Eigen::Matrix&lt;double,dim,3&gt;::Zero();</span>
<a name="l00637"></a>00637 <span class="comment">                                                  </span>
<a name="l00638"></a>00638 <span class="comment">                  Eigen::Matrix&lt;double,3,3&gt; tractionMatrix;</span>
<a name="l00639"></a>00639 <span class="comment">                  for (unsigned int i = 0; i&lt;3; i++){tractionMatrix.col(i) = this-&gt;eleNodes[i]-&gt;traction;}</span>
<a name="l00640"></a>00640 <span class="comment"></span>
<a name="l00641"></a>00641 <span class="comment">                  integrate_Seg&lt;T&gt; (pt,iSeg ,tractionMatrix, tractionInt);</span>
<a name="l00642"></a>00642 <span class="comment">                  </span>
<a name="l00643"></a>00643 <span class="comment">                  return tractionInt;</span>
<a name="l00644"></a>00644 <span class="comment">                }</span>
<a name="l00645"></a>00645 <span class="comment">                </span>
<a name="l00646"></a>00646 <span class="comment">                //=================================================================================================</span>
<a name="l00647"></a>00647 <span class="comment">                // function to integrate the force coming from the infinite medium stress field of a given dislocation segment </span>
<a name="l00648"></a>00648 <span class="comment">                // (over the customly definied Gauss points over the triangle)</span>
<a name="l00649"></a>00649 <span class="comment">                //=================================================================================================</span>
<a name="l00650"></a>00650 <span class="comment">                template &lt; typename T&gt;</span>
<a name="l00651"></a>00651 <span class="comment">                void integrate_Seg (const T* const pt, const unsigned int iSeg, Eigen::Matrix&lt;double,3,3&gt; tractionMatrix , Eigen::Matrix&lt;double,dim,3&gt;&amp; tractionInt ) const {</span>
<a name="l00652"></a>00652 <span class="comment">                  </span>
<a name="l00653"></a>00653 <span class="comment">                  unsigned int iGlide = pt-&gt;link(cuttingSegments[iSeg].first,cuttingSegments[iSeg].second).second-&gt;pGlidePlane-&gt;sID;</span>
<a name="l00654"></a>00654 <span class="comment">                  </span>
<a name="l00655"></a>00655 <span class="comment">                  std::vector&lt;VectorDim&gt; abscissas = localQuadPnts.find(iGlide)-&gt;second;</span>
<a name="l00656"></a>00656 <span class="comment">                  double weight = localQuadPnts_w.find(iGlide)-&gt;second;</span>
<a name="l00657"></a>00657 <span class="comment">                  </span>
<a name="l00658"></a>00658 <span class="comment">                  for (unsigned int i=0; i&lt;abscissas.size(); i++) {</span>
<a name="l00659"></a>00659 <span class="comment">                    tractionInt += dislocationStressKernel_Seg&lt;T&gt; (abscissas[i],pt,tractionMatrix,iSeg);</span>
<a name="l00660"></a>00660 <span class="comment">                  }</span>
<a name="l00661"></a>00661 <span class="comment">                  </span>
<a name="l00662"></a>00662 <span class="comment">                  tractionInt = weight*tractionInt;</span>
<a name="l00663"></a>00663 <span class="comment">                  </span>
<a name="l00664"></a>00664 <span class="comment">                }</span>
<a name="l00665"></a>00665 <span class="comment">                //============================================================================</span>
<a name="l00666"></a>00666 <span class="comment">                // infinite medium stress integration kernel</span>
<a name="l00667"></a>00667 <span class="comment">                //=============================================================================</span>
<a name="l00668"></a>00668 <span class="comment">                template&lt;typename T&gt; </span>
<a name="l00669"></a>00669 <span class="comment">                Eigen::Matrix&lt;double,dim,3&gt; dislocationStressKernel_Seg(const VectorDim&amp; R, const T* const pt, const Eigen::Matrix&lt;double,3,3&gt;&amp; tractionMatrix,const unsigned int iSeg) const {</span>
<a name="l00670"></a>00670 <span class="comment">                  </span>
<a name="l00671"></a>00671 <span class="comment">                        double J = 2.0*area() ;</span>
<a name="l00672"></a>00672 <span class="comment">                        </span>
<a name="l00673"></a>00673 <span class="comment">                        //---------- interpolate externally applied traction between nodes ---------------</span>
<a name="l00674"></a>00674 <span class="comment">                        //Eigen::Matrix&lt;double,1,3&gt; shapeFunc = Shapefunc(Rstd);</span>
<a name="l00675"></a>00675 <span class="comment">                        Eigen::Matrix&lt;unsigned int,2,1&gt; ixy =  find2DProjectionPlane();</span>
<a name="l00676"></a>00676 <span class="comment">                        Eigen::Matrix&lt;double,1,3&gt; shapeFunc = getBarycentric (R , ixy(0) , ixy(1));       // shape functions w.r.t. the parent triangle</span>
<a name="l00677"></a>00677 <span class="comment">                        </span>
<a name="l00678"></a>00678 <span class="comment">                        VectorDim externalTraction = VectorDim::Zero();</span>
<a name="l00679"></a>00679 <span class="comment">                        for (unsigned int i = 0; i&lt;3; i++){externalTraction+=shapeFunc(i)*tractionMatrix.col(i);}</span>
<a name="l00680"></a>00680 <span class="comment">                        </span>
<a name="l00681"></a>00681 <span class="comment">                        //Eigen::Matrix&lt;double,dim,dim&gt; triStress = pts.pt-&gt;stress(R,this-&gt;sID);</span>
<a name="l00682"></a>00682 <span class="comment">                        Eigen::Matrix&lt;double,dim,dim&gt; triStress = pt-&gt;link(cuttingSegments[iSeg].first,cuttingSegments[iSeg].second).second-&gt;stress_source(R);</span>
<a name="l00683"></a>00683 <span class="comment">                        </span>
<a name="l00684"></a>00684 <span class="comment">                        return (externalTraction-(triStress*outNormal))*shapeFunc*J ;</span>
<a name="l00685"></a>00685 <span class="comment">                        //return (externalTraction-(pts.pt-&gt;stress(R,this-&gt;sID)*triN))*shapeFunc*J ;</span>
<a name="l00686"></a>00686 <span class="comment">                </span>
<a name="l00687"></a>00687 <span class="comment">                }</span>
<a name="l00688"></a>00688 <span class="comment">                */</span>
<a name="l00689"></a>00689                 
<a name="l00690"></a>00690                 <span class="comment">//============================================================================</span>
<a name="l00691"></a>00691                 <span class="comment">// function to return the triangle force vector resulted from infinite medium surface traction of a single dislocation segment</span>
<a name="l00692"></a>00692                 <span class="comment">//=============================================================================</span>
<a name="l00693"></a>00693                 <span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt;
<a name="l00694"></a>00694                 Eigen::Matrix&lt;double,dim,3&gt; getTriInfiniteForce_gp (<span class="keyword">const</span> T* <span class="keyword">const</span> pt) {
<a name="l00695"></a>00695                   
<a name="l00696"></a>00696                   <a class="code" href="structbvpfe_1_1_pointer_wrapper.html">PointerWrapper&lt;T&gt;</a> pts(pt);
<a name="l00697"></a>00697                   
<a name="l00698"></a>00698                   Eigen::Matrix&lt;double,dim,3&gt; tractionInt=Eigen::Matrix&lt;double,dim,3&gt;::Zero();
<a name="l00699"></a>00699                                                   
<a name="l00700"></a>00700                   Eigen::Matrix&lt;double,3,3&gt; tractionMatrix;
<a name="l00701"></a>00701                   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i&lt;3; i++){tractionMatrix.col(i) = this-&gt;eleNodes[i]-&gt;traction;}
<a name="l00702"></a>00702 
<a name="l00703"></a>00703                   <span class="keywordflow">if</span> (localQuadPnts.size()!=0) integrate_gp&lt;T&gt; (pt ,tractionMatrix, tractionInt);
<a name="l00704"></a>00704                   <span class="keywordflow">else</span> mmdl::Quadrature&lt;2,3&gt;::integrate(<span class="keyword">this</span>,tractionInt,&amp;Triangle::dislocationStressKernel&lt;<a class="code" href="structbvpfe_1_1_pointer_wrapper.html">PointerWrapper&lt;T&gt;</a> &gt; , pts, outNormal, tractionMatrix);
<a name="l00705"></a>00705                   
<a name="l00706"></a>00706                   <span class="keywordflow">return</span> tractionInt;
<a name="l00707"></a>00707                 }
<a name="l00708"></a>00708                 
<a name="l00709"></a>00709                 <span class="comment">//=================================================================================================</span>
<a name="l00710"></a>00710                 <span class="comment">// function to integrate the force coming from the infinite medium stress field of a given dislocation segment </span>
<a name="l00711"></a>00711                 <span class="comment">// (over the customly definied Gauss points over the triangle)</span>
<a name="l00712"></a>00712                 <span class="comment">//=================================================================================================</span>
<a name="l00713"></a>00713                 <span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt;
<a name="l00714"></a>00714                 <span class="keywordtype">void</span> integrate_gp (<span class="keyword">const</span> T* <span class="keyword">const</span> pt, Eigen::Matrix&lt;double,3,3&gt; tractionMatrix , Eigen::Matrix&lt;double,dim,3&gt;&amp; tractionInt )<span class="keyword"> const </span>{
<a name="l00715"></a>00715                   
<a name="l00716"></a>00716                   <span class="keyword">typename</span> std::map&lt;unsigned int, std::vector&lt;VectorDim&gt;&gt;::const_iterator itt;
<a name="l00717"></a>00717                   <span class="comment">//assert(localQuadPnts.size()==1 &amp;&amp; &quot; extra entities @ localQuadPnts &quot;);</span>
<a name="l00718"></a>00718                   <span class="keywordflow">for</span> (itt=localQuadPnts.begin(); itt!=localQuadPnts.end(); itt++) {
<a name="l00719"></a>00719                     std::vector&lt;VectorDim&gt; abscissas = (*itt).second;
<a name="l00720"></a>00720                     <span class="keywordtype">double</span> weight = 0.5e00 / double (abscissas.size());
<a name="l00721"></a>00721                     
<a name="l00722"></a>00722                     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;abscissas.size(); i++) {
<a name="l00723"></a>00723                       tractionInt += dislocationStressKernel_gp&lt;T&gt; (abscissas[i],pt,tractionMatrix);
<a name="l00724"></a>00724                     }
<a name="l00725"></a>00725                     
<a name="l00726"></a>00726                     tractionInt = weight*tractionInt;
<a name="l00727"></a>00727                   }
<a name="l00728"></a>00728                 }
<a name="l00729"></a>00729                 <span class="comment">//============================================================================</span>
<a name="l00730"></a>00730                 <span class="comment">// infinite medium stress integration kernel</span>
<a name="l00731"></a>00731                 <span class="comment">//=============================================================================</span>
<a name="l00732"></a>00732                 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l00733"></a>00733                 Eigen::Matrix&lt;double,dim,3&gt; dislocationStressKernel_gp(<span class="keyword">const</span> VectorDim&amp; R, <span class="keyword">const</span> T* <span class="keyword">const</span> pt, <span class="keyword">const</span> Eigen::Matrix&lt;double,3,3&gt;&amp; tractionMatrix)<span class="keyword"> const </span>{
<a name="l00734"></a>00734                   
<a name="l00735"></a>00735                         <span class="keywordtype">double</span> J = 2.0*area() ;
<a name="l00736"></a>00736                         
<a name="l00737"></a>00737                         <span class="comment">//---------- interpolate externally applied traction between nodes ---------------</span>
<a name="l00738"></a>00738                         <span class="comment">//Eigen::Matrix&lt;double,1,3&gt; shapeFunc = Shapefunc(Rstd);</span>
<a name="l00739"></a>00739                         Eigen::Matrix&lt;unsigned int,2,1&gt; ixy =  find2DProjectionPlane();
<a name="l00740"></a>00740                         Eigen::Matrix&lt;double,1,3&gt; shapeFunc = getBarycentric (R , ixy(0) , ixy(1));       <span class="comment">// shape functions w.r.t. the parent triangle</span>
<a name="l00741"></a>00741                         
<a name="l00742"></a>00742                         VectorDim externalTraction = VectorDim::Zero();
<a name="l00743"></a>00743                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i&lt;3; i++){externalTraction+=shapeFunc(i)*tractionMatrix.col(i);}
<a name="l00744"></a>00744                         
<a name="l00745"></a>00745                         Eigen::Matrix&lt;double,dim,dim&gt; triStress = pt-&gt;stress(R);
<a name="l00746"></a>00746                         <span class="comment">//Eigen::Matrix&lt;double,dim,dim&gt; triStress = pt-&gt;link(cuttingSegments[iSeg].first,cuttingSegments[iSeg].second).second-&gt;stress_source(R);</span>
<a name="l00747"></a>00747                         
<a name="l00748"></a>00748                         <span class="keywordflow">return</span> (externalTraction-(triStress*outNormal))*shapeFunc*J ;
<a name="l00749"></a>00749                         <span class="comment">//return (externalTraction-(pts.pt-&gt;stress(R,this-&gt;sID)*triN))*shapeFunc*J ;</span>
<a name="l00750"></a>00750                 
<a name="l00751"></a>00751                 }
<a name="l00752"></a>00752                 
<a name="l00753"></a>00753                 <span class="comment">/*</span>
<a name="l00754"></a>00754 <span class="comment">                //============================================================================</span>
<a name="l00755"></a>00755 <span class="comment">                // function to return the sub-triangle force vector resulted from infinite medium surface traction</span>
<a name="l00756"></a>00756 <span class="comment">                //=============================================================================</span>
<a name="l00757"></a>00757 <span class="comment">                template &lt;short unsigned int qOrder, typename T&gt;</span>
<a name="l00758"></a>00758 <span class="comment">                Eigen::Matrix&lt;double,dim,3&gt; subTri_getTriInfiniteForce (const T* const pt , Eigen::Matrix&lt;double,dim,dim&gt; subTriPoints, unsigned int iSeg) {</span>
<a name="l00759"></a>00759 <span class="comment">                  </span>
<a name="l00760"></a>00760 <span class="comment">                  Eigen::Matrix&lt;double,dim,3&gt; tractionInt=Eigen::Matrix&lt;double,dim,3&gt;::Zero();</span>
<a name="l00761"></a>00761 <span class="comment">                  </span>
<a name="l00762"></a>00762 <span class="comment">                  PointerWrapper&lt;T&gt; pts(pt);</span>
<a name="l00763"></a>00763 <span class="comment">                  </span>
<a name="l00764"></a>00764 <span class="comment">                  VectorDim triN = triNormal();</span>
<a name="l00765"></a>00765 <span class="comment">                  </span>
<a name="l00766"></a>00766 <span class="comment">                  Eigen::Matrix&lt;double,3,3&gt; tractionMatrix;</span>
<a name="l00767"></a>00767 <span class="comment">                  for (unsigned int i = 0; i&lt;3; i++){tractionMatrix.col(i) = this-&gt;eleNodes[i]-&gt;traction;}</span>
<a name="l00768"></a>00768 <span class="comment"></span>
<a name="l00769"></a>00769 <span class="comment">                  mmdl::Quadrature&lt;2,qOrder&gt;::integrate(this,tractionInt,&amp;Triangle::subTri_dislocationStressKernel&lt;PointerWrapper&lt;T&gt; &gt; , pts, triN, tractionMatrix, subTriPoints , iSeg );</span>
<a name="l00770"></a>00770 <span class="comment">                  </span>
<a name="l00771"></a>00771 <span class="comment">                  return tractionInt;</span>
<a name="l00772"></a>00772 <span class="comment">                }</span>
<a name="l00773"></a>00773 <span class="comment">                </span>
<a name="l00774"></a>00774 <span class="comment">                </span>
<a name="l00775"></a>00775 <span class="comment">                //============================================================================</span>
<a name="l00776"></a>00776 <span class="comment">                // infinite medium stress integration kernel on subtriangle</span>
<a name="l00777"></a>00777 <span class="comment">                //=============================================================================</span>
<a name="l00778"></a>00778 <span class="comment">                template&lt;typename T&gt; </span>
<a name="l00779"></a>00779 <span class="comment">                Eigen::Matrix&lt;double,dim,3&gt; subTri_dislocationStressKernel(const Eigen::Matrix&lt;double,2,1&gt;&amp; Rstd, const T&amp; pts, const VectorDim&amp; triN, </span>
<a name="l00780"></a>00780 <span class="comment">                                                                           const Eigen::Matrix&lt;double,3,3&gt;&amp; tractionMatrix,const Eigen::Matrix&lt;double,dim,dim&gt;&amp; subTriPoints,</span>
<a name="l00781"></a>00781 <span class="comment">                                                                           const unsigned int&amp; iSeg) const {</span>
<a name="l00782"></a>00782 <span class="comment">                        double J ;</span>
<a name="l00783"></a>00783 <span class="comment">                        VectorDim R=subTri_mapStdPoint&lt;2&gt;(subTriPoints,Rstd,J);</span>
<a name="l00784"></a>00784 <span class="comment">                        //std::cout&lt;&lt; R.transpose() &lt;&lt; std::endl;</span>
<a name="l00785"></a>00785 <span class="comment">                        //VectorDim R=mapStdPoint&lt;2&gt;(Rstd,J);</span>
<a name="l00786"></a>00786 <span class="comment">                        </span>
<a name="l00787"></a>00787 <span class="comment">                        //---------- interpolate externally applied traction between nodes ---------------</span>
<a name="l00788"></a>00788 <span class="comment">                        VectorDim externalTraction = VectorDim::Zero();</span>
<a name="l00789"></a>00789 <span class="comment">                        </span>
<a name="l00790"></a>00790 <span class="comment">                        //Eigen::Matrix&lt;double,1,3&gt; shapeFunc = Shapefunc(Rstd);</span>
<a name="l00791"></a>00791 <span class="comment">                        </span>
<a name="l00792"></a>00792 <span class="comment">                        Eigen::Matrix&lt;unsigned int,2,1&gt; ixy =  find2DProjectionPlane();</span>
<a name="l00793"></a>00793 <span class="comment">                        Eigen::Matrix&lt;double,1,3&gt; shapeFunc = getBarycentric (R , ixy(0) , ixy(1));       // shape functions w.r.t. the parent triangle</span>
<a name="l00794"></a>00794 <span class="comment">                        </span>
<a name="l00795"></a>00795 <span class="comment">                        for (unsigned int i = 0; i&lt;3; i++){externalTraction+=shapeFunc(i)*tractionMatrix.col(i);}</span>
<a name="l00796"></a>00796 <span class="comment">                        </span>
<a name="l00797"></a>00797 <span class="comment">                        //Eigen::Matrix&lt;double,dim,dim&gt; triStress = pts.pt-&gt;stress(R,this-&gt;sID);</span>
<a name="l00798"></a>00798 <span class="comment">                        Eigen::Matrix&lt;double,dim,dim&gt; triStress = pts.pt-&gt;link(cuttingSegments[iSeg].first,cuttingSegments[iSeg].second).second-&gt;stress_source(R);</span>
<a name="l00799"></a>00799 <span class="comment">                        </span>
<a name="l00800"></a>00800 <span class="comment">                        //std::cout&lt;&lt; this-&gt;sID &lt;&lt; &quot; : &quot;&lt;&lt; triStress.col(0).transpose() &lt;&lt; &quot; &quot; &lt;&lt;triStress.col(1).transpose() &lt;&lt; &quot; &quot; &lt;&lt;triStress.col(2).transpose() &lt;&lt;std::endl;    </span>
<a name="l00801"></a>00801 <span class="comment">                        //if (this-&gt;sID==428||this-&gt;sID==471||this-&gt;sID==1895||this-&gt;sID==1899||this-&gt;sID==1898||this-&gt;sID==442||this-&gt;sID==805) {</span>
<a name="l00802"></a>00802 <span class="comment">//                      if (this-&gt;sID==26||this-&gt;sID==457||this-&gt;sID==927||this-&gt;sID==456||this-&gt;sID==935 </span>
<a name="l00803"></a>00803 <span class="comment">//                          || this-&gt;sID==428||this-&gt;sID==471||this-&gt;sID==1895||this-&gt;sID==1899||this-&gt;sID==1898||this-&gt;sID==442||this-&gt;sID==805) {</span>
<a name="l00804"></a>00804 <span class="comment">//                        std::cout&lt;&lt; this-&gt;sID &lt;&lt; &quot; : &quot;&lt;&lt; triStress.col(0).transpose() &lt;&lt; &quot; &quot; &lt;&lt;triStress.col(1).transpose() &lt;&lt; &quot; &quot; &lt;&lt;triStress.col(2).transpose() &lt;&lt;std::endl;  </span>
<a name="l00805"></a>00805 <span class="comment">//                      }</span>
<a name="l00806"></a>00806 <span class="comment">                        return (externalTraction-(triStress*triN))*shapeFunc*J ;</span>
<a name="l00807"></a>00807 <span class="comment">                        //return (externalTraction-(pts.pt-&gt;stress(R,this-&gt;sID)*triN))*shapeFunc*J ;</span>
<a name="l00808"></a>00808 <span class="comment">                </span>
<a name="l00809"></a>00809 <span class="comment">                }</span>
<a name="l00810"></a>00810 <span class="comment">                </span>
<a name="l00811"></a>00811 <span class="comment">                //==============================================================================</span>
<a name="l00812"></a>00812 <span class="comment">                // function to map the Gauss point to the actual domain in a subtriangle</span>
<a name="l00813"></a>00813 <span class="comment">                //==============================================================================</span>
<a name="l00814"></a>00814 <span class="comment">                template&lt;short unsigned int OtherDim&gt;</span>
<a name="l00815"></a>00815 <span class="comment">                VectorDim subTri_mapStdPoint(const Eigen::Matrix&lt;double,dim,dim&gt; subTriPoints, const Eigen::Matrix&lt;double,2,1&gt;&amp; Rstd, double&amp; J) const {</span>
<a name="l00816"></a>00816 <span class="comment">                        </span>
<a name="l00817"></a>00817 <span class="comment">                  Eigen::Matrix&lt;double,dim,OtherDim&gt; A;</span>
<a name="l00818"></a>00818 <span class="comment">                  //VectorDim b = this-&gt;eleNodes[0]-&gt;P;</span>
<a name="l00819"></a>00819 <span class="comment">                  VectorDim b = subTriPoints.col(0);</span>
<a name="l00820"></a>00820 <span class="comment">                  </span>
<a name="l00821"></a>00821 <span class="comment">                  Eigen::Matrix&lt;double,dim,1&gt; temp;</span>
<a name="l00822"></a>00822 <span class="comment">                  </span>
<a name="l00823"></a>00823 <span class="comment">                    for (int i = 0; i&lt;OtherDim; i++){</span>
<a name="l00824"></a>00824 <span class="comment">                                //A.col(i) = this-&gt;eleNodes[i+1]-&gt;P - this-&gt;eleNodes[0]-&gt;P;</span>
<a name="l00825"></a>00825 <span class="comment">                                A.col(i) = subTriPoints.col(i+1) - subTriPoints.col(0);</span>
<a name="l00826"></a>00826 <span class="comment">                    }</span>
<a name="l00827"></a>00827 <span class="comment">                </span>
<a name="l00828"></a>00828 <span class="comment">                    temp = A.col(0).cross(A.col(1));</span>
<a name="l00829"></a>00829 <span class="comment">                    J= temp.norm();    // this is = area of actual triangle * 2 , but the sum of integration weights for triangle is actually in this code (1/2)               </span>
<a name="l00830"></a>00830 <span class="comment">                    </span>
<a name="l00831"></a>00831 <span class="comment">                    assert(J&gt;0.0);</span>
<a name="l00832"></a>00832 <span class="comment">                    return  A * Rstd +b ; </span>
<a name="l00833"></a>00833 <span class="comment">                }</span>
<a name="l00834"></a>00834 <span class="comment">                */</span>
<a name="l00835"></a>00835                 
<a name="l00836"></a>00836                 
<a name="l00837"></a>00837                 <span class="comment">//==========================================================================================</span>
<a name="l00838"></a>00838                 <span class="comment">// function to generate a custom set of quadrature points oriented with the glide plane - triangle intersection line</span>
<a name="l00839"></a>00839                 <span class="comment">//==================================================================================================</span>
<a name="l00840"></a>00840                 
<a name="l00841"></a>00841                 <span class="keywordtype">void</span> makeLocalQuadPoints (VectorDim P0, VectorDim P1,  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gpID) {
<a name="l00842"></a>00842                   
<a name="l00843"></a>00843                   <span class="keywordtype">double</span> dl = 20.0e00;                      <span class="comment">// the separation distance between the quadrature points rows</span>
<a name="l00844"></a>00844                   
<a name="l00845"></a>00845                   std::vector&lt;VectorDim&gt; QuadPointsSet;      <span class="comment">// vector accumulates the generated points</span>
<a name="l00846"></a>00846                   std::vector&lt;VectorDim&gt; rowPointsSet;
<a name="l00847"></a>00847                   
<a name="l00848"></a>00848                   projPlaneIndx= find2DProjectionPlane();
<a name="l00849"></a>00849                   
<a name="l00850"></a>00850                   VectorDim cp = 0.5*(P0 + P1);  
<a name="l00851"></a>00851                   VectorDim uv = (P1-P0).normalized();
<a name="l00852"></a>00852                   VectorDim nd = outNormal.cross(uv);           <span class="comment">// vector perpendicular to the intersection line, on the triangle plane</span>
<a name="l00853"></a>00853                   
<a name="l00854"></a>00854                   <span class="keywordtype">bool</span> done;
<a name="l00855"></a>00855                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iRow;
<a name="l00856"></a>00856                   <span class="comment">//--------- populate first in the +ve side of the nd ---------</span>
<a name="l00857"></a>00857                   done = <span class="keyword">false</span>;
<a name="l00858"></a>00858                   iRow = 0;
<a name="l00859"></a>00859                   <span class="keywordflow">while</span> (!done) {
<a name="l00860"></a>00860                     iRow ++;
<a name="l00861"></a>00861                     <span class="comment">//rowPointsSet  = makeOneRow(dl,cp,uv,nd,iRow);</span>
<a name="l00862"></a>00862                     rowPointsSet  = makeOneRow_onLine(dl,cp,uv,nd,iRow);
<a name="l00863"></a>00863                     
<a name="l00864"></a>00864                     <span class="keywordflow">if</span>(rowPointsSet.size()&gt;0) QuadPointsSet.insert( QuadPointsSet.begin(), rowPointsSet.begin() , rowPointsSet.end() );
<a name="l00865"></a>00865                     <span class="keywordflow">else</span> done = <span class="keyword">true</span>;
<a name="l00866"></a>00866                   }
<a name="l00867"></a>00867                   <span class="comment">//--------- populate first in the -ve side of the nd ---------</span>
<a name="l00868"></a>00868                   done = <span class="keyword">false</span>;
<a name="l00869"></a>00869                   iRow = 0;
<a name="l00870"></a>00870                   <span class="keywordflow">while</span> (!done) {
<a name="l00871"></a>00871                     iRow ++;
<a name="l00872"></a>00872                     <span class="comment">//rowPointsSet  = makeOneRow(dl,cp,uv,-nd,iRow);</span>
<a name="l00873"></a>00873                     rowPointsSet  = makeOneRow_onLine(dl,cp,uv,-nd,iRow);
<a name="l00874"></a>00874                     
<a name="l00875"></a>00875                     <span class="keywordflow">if</span>(rowPointsSet.size()&gt;0) QuadPointsSet.insert( QuadPointsSet.begin(), rowPointsSet.begin() , rowPointsSet.end() );
<a name="l00876"></a>00876                     <span class="keywordflow">else</span> done = <span class="keyword">true</span>;
<a name="l00877"></a>00877                   }
<a name="l00878"></a>00878                   
<a name="l00879"></a>00879                   assert(QuadPointsSet.size() &gt; 0 &amp;&amp; <span class="stringliteral">&quot; failed to generate quadrature points around the glide plane intersection line on mesh triangles &quot;</span> );
<a name="l00880"></a>00880                   
<a name="l00881"></a>00881                   <span class="keywordtype">double</span> w = 0.5e00 / double (QuadPointsSet.size());      <span class="comment">// the sum of all weights should be 0.5</span>
<a name="l00882"></a>00882                   
<a name="l00883"></a>00883                   <span class="comment">//for (unsigned int i=0; i&lt;QuadPointsSet.size(); i++) std::cout&lt;&lt; QuadPointsSet[i].transpose()&lt;&lt;std::endl; </span>
<a name="l00884"></a>00884                   
<a name="l00885"></a>00885                   localQuadPnts.insert  ( std::make_pair( gpID , QuadPointsSet ) );
<a name="l00886"></a>00886                   localQuadPnts_w.insert( std::make_pair( gpID , w ) );
<a name="l00887"></a>00887                   
<a name="l00888"></a>00888                 }
<a name="l00889"></a>00889                 
<a name="l00890"></a>00890                 <span class="comment">//==================================================================================</span>
<a name="l00891"></a>00891                 <span class="comment">// function to add one row to the custom made quadrature points for each triangle</span>
<a name="l00892"></a>00892                 <span class="comment">//===================================================================================</span>
<a name="l00893"></a>00893                 
<a name="l00894"></a>00894                 std::vector&lt;VectorDim&gt; makeOneRow(<span class="keyword">const</span> <span class="keywordtype">double</span> dl, <span class="keyword">const</span> VectorDim cp, <span class="keyword">const</span> VectorDim uv, <span class="keyword">const</span> VectorDim nd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iRow ) {
<a name="l00895"></a>00895                   std::vector&lt;VectorDim&gt; rowPointsSet;
<a name="l00896"></a>00896                   
<a name="l00897"></a>00897                   VectorDim P0, P ;
<a name="l00898"></a>00898                   Eigen::Matrix&lt;double,3,1&gt;::Index iBary;
<a name="l00899"></a>00899                   Eigen::Matrix&lt;double,3,1&gt; Bary; 
<a name="l00900"></a>00900                   <span class="keywordtype">double</span> baryMin;
<a name="l00901"></a>00901                   
<a name="l00902"></a>00902                   <span class="keywordtype">bool</span> endOfSide;
<a name="l00903"></a>00903                   
<a name="l00904"></a>00904                   <span class="comment">//------- add a point at the center ------------</span>
<a name="l00905"></a>00905                   P0 = cp + (iRow*dl*nd);
<a name="l00906"></a>00906                   Bary = getBarycentric(P0,projPlaneIndx(0),projPlaneIndx(1));
<a name="l00907"></a>00907                   baryMin = Bary.minCoeff(&amp;iBary);
<a name="l00908"></a>00908                   <span class="comment">//std::cout &lt;&lt; Bary.transpose() &lt;&lt; std::endl;</span>
<a name="l00909"></a>00909                   <span class="keywordflow">if</span> (baryMin&gt;0.0) rowPointsSet.push_back(P0);
<a name="l00910"></a>00910 
<a name="l00911"></a>00911                   <span class="comment">//--------- move in +ve side of uv -----------</span>
<a name="l00912"></a>00912                   endOfSide = <span class="keyword">false</span>;
<a name="l00913"></a>00913                   P = P0;
<a name="l00914"></a>00914                   
<a name="l00915"></a>00915                   <span class="keywordflow">while</span> (!endOfSide) {
<a name="l00916"></a>00916                     P = P + (dl*uv);
<a name="l00917"></a>00917                     Bary = getBarycentric(P,projPlaneIndx(0),projPlaneIndx(1));
<a name="l00918"></a>00918                     <span class="comment">//std::cout &lt;&lt; Bary.transpose() &lt;&lt; std::endl;</span>
<a name="l00919"></a>00919                     endOfSide = Bary.minCoeff(&amp;iBary) &lt;= 0.0;
<a name="l00920"></a>00920                     
<a name="l00921"></a>00921                     <span class="keywordflow">if</span> (!endOfSide) rowPointsSet.push_back(P);
<a name="l00922"></a>00922                   }
<a name="l00923"></a>00923                   
<a name="l00924"></a>00924                   <span class="comment">//--------- move in -ve side of uv -----------</span>
<a name="l00925"></a>00925                   endOfSide = <span class="keyword">false</span>;
<a name="l00926"></a>00926                   P = P0;
<a name="l00927"></a>00927                   
<a name="l00928"></a>00928                   <span class="keywordflow">while</span> (!endOfSide) {
<a name="l00929"></a>00929                     P = P - (dl*uv);
<a name="l00930"></a>00930                     Bary = getBarycentric(P,projPlaneIndx(0),projPlaneIndx(1));
<a name="l00931"></a>00931                     <span class="comment">//std::cout &lt;&lt; Bary.transpose() &lt;&lt; std::endl;</span>
<a name="l00932"></a>00932                     endOfSide = Bary.minCoeff(&amp;iBary) &lt;= 0.0;
<a name="l00933"></a>00933                     
<a name="l00934"></a>00934                     <span class="keywordflow">if</span> (!endOfSide) rowPointsSet.push_back(P);
<a name="l00935"></a>00935                   }
<a name="l00936"></a>00936                   
<a name="l00937"></a>00937                   <span class="keywordflow">return</span> rowPointsSet;
<a name="l00938"></a>00938                 }
<a name="l00939"></a>00939                 
<a name="l00940"></a>00940                 
<a name="l00941"></a>00941                 <span class="comment">//==================================================================================</span>
<a name="l00942"></a>00942                 <span class="comment">// function to add one row to the custom made quadrature points for each triangle</span>
<a name="l00943"></a>00943                 <span class="comment">//===================================================================================</span>
<a name="l00944"></a>00944                 
<a name="l00945"></a>00945                 std::vector&lt;VectorDim&gt; makeOneRow_onLine(<span class="keyword">const</span> <span class="keywordtype">double</span> dl, <span class="keyword">const</span> VectorDim cp, <span class="keyword">const</span> VectorDim uv, <span class="keyword">const</span> VectorDim nd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iRow ) {
<a name="l00946"></a>00946                   std::vector&lt;VectorDim&gt; rowPointsSet;
<a name="l00947"></a>00947                   
<a name="l00948"></a>00948                   VectorDim c0, p0 , p1 , x0 , x1 , P , v ;
<a name="l00949"></a>00949                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nPnts;
<a name="l00950"></a>00950                   <span class="keywordtype">double</span> dx , l;
<a name="l00951"></a>00951                   
<a name="l00952"></a>00952                   <span class="comment">//------- get end points of the new line ------------</span>
<a name="l00953"></a>00953                   c0 = cp + (iRow*dl*nd);
<a name="l00954"></a>00954                   <span class="comment">//std::cout&lt;&lt; c0.transpose() &lt;&lt; std::endl;</span>
<a name="l00955"></a>00955                   p0 = c0 - (1.0e4*uv);
<a name="l00956"></a>00956                   p1 = c0 + (1.0e4*uv);
<a name="l00957"></a>00957                   
<a name="l00958"></a>00958                   <span class="comment">//------------------ implement intersection  with the 3 triangle edges -----------</span>
<a name="l00959"></a>00959                   <span class="keywordflow">if</span> (intersectLineWithEdges(p0,p1,x0,x1)) {
<a name="l00960"></a>00960                     l = (x1-x0).norm();
<a name="l00961"></a>00961                     v = (x1-x0).normalized();
<a name="l00962"></a>00962                     nPnts = int( l / dl) + 1;              <span class="comment">// number of points on the line</span>
<a name="l00963"></a>00963                     dx = 0.5e00 * ( l - ((nPnts-1)*dl) );
<a name="l00964"></a>00964                     
<a name="l00965"></a>00965                     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nPnts; i++){
<a name="l00966"></a>00966                       P = x0 + (dx+(i*dl))*v;
<a name="l00967"></a>00967                       rowPointsSet.push_back(P);
<a name="l00968"></a>00968                     }
<a name="l00969"></a>00969                   }    
<a name="l00970"></a>00970                   <span class="keywordflow">return</span> rowPointsSet;
<a name="l00971"></a>00971                 }
<a name="l00972"></a>00972                 
<a name="l00973"></a>00973                 <span class="comment">//===========================================================================================</span>
<a name="l00974"></a>00974                 <span class="comment">// function to intersect a line with the 3 triangle edges, and update the 2 intersection points</span>
<a name="l00975"></a>00975                 <span class="comment">//===========================================================================================</span>
<a name="l00976"></a>00976                 
<a name="l00977"></a>00977                 <span class="keywordtype">bool</span> intersectLineWithEdges (VectorDim p0, VectorDim p1, VectorDim&amp; x0, VectorDim&amp; x1) {
<a name="l00978"></a>00978                   <span class="comment">//VectorDim x0 , x1 ;</span>
<a name="l00979"></a>00979                   <span class="keywordtype">bool</span> intersectionFound = <span class="keyword">false</span>;
<a name="l00980"></a>00980                   
<a name="l00981"></a>00981                   Eigen::Matrix&lt;double,2,2&gt; mat;
<a name="l00982"></a>00982                   Eigen::Matrix&lt;double,2,1&gt; u,b;
<a name="l00983"></a>00983                   
<a name="l00984"></a>00984                   std::vector&lt;VectorDim&gt; intersectionPoints;
<a name="l00985"></a>00985                   VectorDim temp;
<a name="l00986"></a>00986                   
<a name="l00987"></a>00987                   Eigen::Matrix&lt;unsigned int,2,1&gt; ppindx= find2DProjectionPlane();
<a name="l00988"></a>00988                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ix = ppindx(0);
<a name="l00989"></a>00989                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iy = ppindx(1);
<a name="l00990"></a>00990                   
<a name="l00991"></a>00991                   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;3; i++){               <span class="comment">// loop over the 3 triangle edges</span>
<a name="l00992"></a>00992                     x0 = this-&gt;eleNodes[(i+1)%3]-&gt;P;
<a name="l00993"></a>00993                     x1 = this-&gt;eleNodes[(i+2)%3]-&gt;P;
<a name="l00994"></a>00994                     
<a name="l00995"></a>00995                     mat(0,0) = p1(ix) - p0(ix);        mat(0,1) = x0(ix) - x1(ix);    
<a name="l00996"></a>00996                     mat(1,0) = p1(iy) - p0(iy);        mat(1,1) = x0(iy) - x1(iy);
<a name="l00997"></a>00997                     
<a name="l00998"></a>00998                     b(0) = x0(ix) - p0(ix);
<a name="l00999"></a>00999                     b(1) = x0(iy) - p0(iy);
<a name="l01000"></a>01000                     
<a name="l01001"></a>01001                     u = mat.inverse()*b;
<a name="l01002"></a>01002                     
<a name="l01003"></a>01003                     <span class="keywordflow">if</span> ( u(1) &gt;= 0.0e00  &amp;&amp; u(1) &lt;=1.0e00) {       <span class="comment">// intersection point is within the triangle line segments</span>
<a name="l01004"></a>01004                       temp = x0 + u(1)*(x1-x0);
<a name="l01005"></a>01005                       intersectionPoints.push_back(temp);
<a name="l01006"></a>01006                     }
<a name="l01007"></a>01007                   }
<a name="l01008"></a>01008                   
<a name="l01009"></a>01009                   <span class="keywordflow">if</span>(intersectionPoints.size()==3) {      <span class="comment">// when one of the intersection points is a vertex</span>
<a name="l01010"></a>01010                     <span class="keywordtype">int</span> repeatedPoint = -1; 
<a name="l01011"></a>01011                     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i1=0; i1&lt;intersectionPoints.size();i1++){
<a name="l01012"></a>01012                       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i2=i1+1; i2&lt;intersectionPoints.size(); i2++){
<a name="l01013"></a>01013                         <span class="keywordflow">if</span> ((intersectionPoints[i1]-intersectionPoints[i2]).norm() &lt; 1.0e-8 ) repeatedPoint = i1; 
<a name="l01014"></a>01014                       }
<a name="l01015"></a>01015                     }
<a name="l01016"></a>01016                     
<a name="l01017"></a>01017                     <span class="keywordflow">if</span> (repeatedPoint != -1) intersectionPoints.erase(intersectionPoints.begin()+repeatedPoint);
<a name="l01018"></a>01018                   }
<a name="l01019"></a>01019                   
<a name="l01020"></a>01020                   <span class="keywordflow">if</span>(intersectionPoints.size()==2) {     <span class="comment">// found 2 intersection points</span>
<a name="l01021"></a>01021                     x0 = intersectionPoints[0];
<a name="l01022"></a>01022                     x1 = intersectionPoints[1];
<a name="l01023"></a>01023                     intersectionFound = <span class="keyword">true</span>;
<a name="l01024"></a>01024                   }
<a name="l01025"></a>01025                   <span class="keywordflow">else</span> intersectionFound = <span class="keyword">false</span>;
<a name="l01026"></a>01026                   
<a name="l01027"></a>01027                   <span class="keywordflow">return</span> intersectionFound;
<a name="l01028"></a>01028                 }
<a name="l01029"></a>01029                 
<a name="l01030"></a>01030                 <span class="comment">//==============================================================================</span>
<a name="l01031"></a>01031                 Eigen::Matrix&lt;double,3,1&gt;  getBarycentric (VectorDim P , <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ix  , <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iy  )<span class="keyword"> const</span>
<a name="l01032"></a>01032 <span class="keyword">                </span>{
<a name="l01033"></a>01033                         Eigen::Matrix&lt;double,3,1&gt; bary;
<a name="l01034"></a>01034                         <span class="keywordtype">double</span> V0;
<a name="l01035"></a>01035                         
<a name="l01036"></a>01036                         V0 = getVol(this-&gt;eleNodes[0]-&gt;P,this-&gt;eleNodes[1]-&gt;P,this-&gt;eleNodes[2]-&gt;P ,ix, iy);
<a name="l01037"></a>01037                         
<a name="l01038"></a>01038                         bary(0) = getVol(                   P,this-&gt;eleNodes[1]-&gt;P,this-&gt;eleNodes[2]-&gt;P,  ix,  iy)/V0;
<a name="l01039"></a>01039                         bary(1) = getVol(this-&gt;eleNodes[0]-&gt;P,                   P,this-&gt;eleNodes[2]-&gt;P,  ix,  iy)/V0;
<a name="l01040"></a>01040                         bary(2) = getVol(this-&gt;eleNodes[0]-&gt;P,this-&gt;eleNodes[1]-&gt;P,                   P,  ix,  iy)/V0;
<a name="l01041"></a>01041                         
<a name="l01042"></a>01042                         <span class="keywordflow">return</span> bary;
<a name="l01043"></a>01043                 }
<a name="l01044"></a>01044                 
<a name="l01045"></a>01045                 <span class="comment">//======================================================================</span>
<a name="l01046"></a>01046                 <span class="comment">// return the volume of the tetradedron, given its points coordinates in order</span>
<a name="l01047"></a>01047                 <span class="comment">//======================================================================</span>
<a name="l01048"></a>01048                 <span class="keywordtype">double</span> getVol(VectorDim a, VectorDim b, VectorDim c , <span class="keywordtype">int</span> ix, <span class="keywordtype">int</span> iy)<span class="keyword"> const</span>
<a name="l01049"></a>01049 <span class="keyword">                </span>{
<a name="l01050"></a>01050 
<a name="l01051"></a>01051                         MatrixDim temp;
<a name="l01052"></a>01052                         
<a name="l01053"></a>01053                         temp &lt;&lt; a(ix), b(ix), c(ix),
<a name="l01054"></a>01054                                 a(iy), b(iy), c(iy),
<a name="l01055"></a>01055                                 1   , 1   , 1; 
<a name="l01056"></a>01056                                 
<a name="l01057"></a>01057                         <span class="keywordflow">return</span> temp.determinant()/2.0;
<a name="l01058"></a>01058                 }
<a name="l01059"></a>01059                 
<a name="l01060"></a>01060                 
<a name="l01061"></a>01061                 
<a name="l01062"></a>01062                 
<a name="l01063"></a>01063                 
<a name="l01064"></a>01064                 
<a name="l01065"></a>01065                 
<a name="l01067"></a>01067                 
<a name="l01068"></a>01068                 
<a name="l01069"></a>01069                 
<a name="l01070"></a>01070                 
<a name="l01071"></a>01071                 
<a name="l01072"></a>01072                 <span class="comment">//============================================================================</span>
<a name="l01073"></a>01073                 <span class="comment">// function to return the triangle infinite medium surface traction vector resulted from infinite medium dislocations field</span>
<a name="l01074"></a>01074                 <span class="comment">//=============================================================================</span>
<a name="l01075"></a>01075                 <span class="keyword">template</span> &lt;<span class="keywordtype">short</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qOrder, <span class="keywordtype">bool</span> deformed = false , <span class="keyword">typename</span> T&gt;
<a name="l01076"></a>01076                 Eigen::Matrix&lt;double,dim,1&gt; getTriInfiniteTraction (<span class="keyword">const</span> T* <span class="keyword">const</span> pt)<span class="keyword"> const </span>{
<a name="l01077"></a>01077                   
<a name="l01078"></a>01078                   Eigen::Matrix&lt;double,dim,1&gt; tractionInt=Eigen::Matrix&lt;double,dim,1&gt;::Zero();
<a name="l01079"></a>01079                   
<a name="l01080"></a>01080                   <a class="code" href="structbvpfe_1_1_pointer_wrapper.html">PointerWrapper&lt;T&gt;</a> pts(pt);
<a name="l01081"></a>01081                   VectorDim triN;
<a name="l01082"></a>01082                   
<a name="l01083"></a>01083                   <span class="keywordflow">if</span> (deformed) triN = triNormalDeformed();
<a name="l01084"></a>01084                   <span class="keywordflow">else</span> triN = outNormal;
<a name="l01085"></a>01085                   
<a name="l01086"></a>01086                   <span class="keywordflow">if</span> (localQuadPnts.size()!=0) integrate_gp&lt;T&gt; (pt , tractionInt);
<a name="l01087"></a>01087                   <span class="keywordflow">else</span> mmdl::Quadrature&lt;2,qOrder&gt;::integrate(<span class="keyword">this</span>,tractionInt,&amp;Triangle::dislocationStressKernel&lt;<a class="code" href="structbvpfe_1_1_pointer_wrapper.html">PointerWrapper&lt;T&gt;</a> &gt; , pts, triN);
<a name="l01088"></a>01088                   
<a name="l01089"></a>01089                   <span class="keywordflow">return</span> tractionInt;
<a name="l01090"></a>01090                 }
<a name="l01091"></a>01091                 
<a name="l01092"></a>01092                 <span class="comment">//=================================================================================================</span>
<a name="l01093"></a>01093                 <span class="comment">// function to integrate the force coming from the infinite medium stress field of a given dislocation segment </span>
<a name="l01094"></a>01094                 <span class="comment">// (over the customly definied Gauss points over the triangle)</span>
<a name="l01095"></a>01095                 <span class="comment">//=================================================================================================</span>
<a name="l01096"></a>01096                 <span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt;
<a name="l01097"></a>01097                 <span class="keywordtype">void</span> integrate_gp (<span class="keyword">const</span> T* <span class="keyword">const</span> pt , Eigen::Matrix&lt;double,dim,1&gt;&amp; tractionInt )<span class="keyword"> const </span>{
<a name="l01098"></a>01098                   
<a name="l01099"></a>01099                   <span class="keyword">typename</span> std::map&lt;unsigned int, std::vector&lt;VectorDim&gt;&gt;::const_iterator itt;
<a name="l01100"></a>01100 
<a name="l01101"></a>01101                   <span class="keywordflow">for</span> (itt=localQuadPnts.begin(); itt!=localQuadPnts.end(); itt++) {
<a name="l01102"></a>01102                     std::vector&lt;VectorDim&gt; abscissas = (*itt).second;
<a name="l01103"></a>01103                     <span class="keywordtype">double</span> weight = 0.5e00 / double (abscissas.size());
<a name="l01104"></a>01104                     
<a name="l01105"></a>01105                     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;abscissas.size(); i++) {
<a name="l01106"></a>01106                       tractionInt += pt-&gt;stress(abscissas[i])*outNormal;
<a name="l01107"></a>01107                     }
<a name="l01108"></a>01108                     
<a name="l01109"></a>01109                     tractionInt = 2.0*area()*weight*tractionInt;
<a name="l01110"></a>01110                   }
<a name="l01111"></a>01111                 }
<a name="l01112"></a>01112 
<a name="l01113"></a>01113                 <span class="comment">//============================================================================</span>
<a name="l01114"></a>01114                 <span class="comment">// infinite medium surface traction integration kernel</span>
<a name="l01115"></a>01115                 <span class="comment">//=============================================================================</span>
<a name="l01116"></a>01116                 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; 
<a name="l01117"></a>01117                 Eigen::Matrix&lt;double,dim,1&gt; dislocationStressKernel(<span class="keyword">const</span> Eigen::Matrix&lt;double,2,1&gt;&amp; Rstd, <span class="keyword">const</span> T&amp; pts, <span class="keyword">const</span> VectorDim&amp; triN)<span class="keyword"> const </span>{
<a name="l01118"></a>01118                         <span class="keywordtype">double</span> J ;
<a name="l01119"></a>01119                         VectorDim R=mapStdPoint&lt;2&gt;(Rstd,J);
<a name="l01120"></a>01120                         <span class="keywordflow">return</span> (pts.pt-&gt;stress(R)*triN)*J ;
<a name="l01121"></a>01121                 }
<a name="l01122"></a>01122         
<a name="l01123"></a>01123                 <span class="comment">//============================================================================</span>
<a name="l01124"></a>01124                 <span class="comment">// function to return the triangle infinite medium force vector resulted from infinite medium dislocations field</span>
<a name="l01125"></a>01125                 <span class="comment">//=============================================================================</span>
<a name="l01126"></a>01126                 <span class="keyword">template</span> &lt;<span class="keywordtype">short</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qOrder, <span class="keywordtype">bool</span> deformed = false , <span class="keyword">typename</span> T&gt;
<a name="l01127"></a>01127                 Eigen::Matrix&lt;double,dim,1&gt; forceInfinite (<span class="keyword">const</span> T* <span class="keyword">const</span> pt)<span class="keyword"> const </span>{
<a name="l01128"></a>01128                   
<a name="l01129"></a>01129                   <span class="keywordtype">double</span> triArea;
<a name="l01130"></a>01130                   
<a name="l01131"></a>01131                   <span class="keywordflow">if</span> (deformed) triArea = deformed_area();
<a name="l01132"></a>01132                   <span class="keywordflow">else</span> triArea = area();
<a name="l01133"></a>01133                   
<a name="l01134"></a>01134                   <span class="keywordflow">return</span> triArea*getTriInfiniteTraction&lt;qOrder,deformed,T&gt;(pt);
<a name="l01135"></a>01135                 }
<a name="l01136"></a>01136                 
<a name="l01137"></a>01137                 
<a name="l01138"></a>01138         };
<a name="l01139"></a>01139         
<a name="l01140"></a>01140 <span class="comment">//------------ redefine the static variable [required] ------------</span>
<a name="l01141"></a>01141         <span class="keywordtype">double</span> Triangle::N[3][3] ;
<a name="l01142"></a>01142         <span class="keywordtype">double</span> Triangle::edgeTol = 1.0e-02;
<a name="l01143"></a>01143         
<a name="l01144"></a>01144 }  <span class="comment">//  namespace bvpfe</span>
<a name="l01145"></a>01145 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 12 2012 17:24:28 for Mechanics of Defect Evolution Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
