<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Mechanics of Defect Evolution Library: /home/giacomo/Dropbox/Model/model/BVP/Domain.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://www.mathjax.org/mathjax/MathJax.js"></script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="UCLA_LOGO.jpeg"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mechanics of Defect Evolution Library
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/giacomo/Dropbox/Model/model/BVP/Domain.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* This file is part of finite element solution of BVP attached with mmdl &quot;the Mechanics of Material Defects Library&quot;.</span>
<a name="l00002"></a>00002 <span class="comment"> *</span>
<a name="l00003"></a>00003 <span class="comment"> * Copyright (C) 2011 by Mamdouh Mohamed &lt;mamdouh.s.mohamed@gmail.com&gt;, </span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (C) 2011 by Giacomo Po &lt;giacomopo@gmail.com&gt;.</span>
<a name="l00005"></a>00005 <span class="comment"> * </span>
<a name="l00006"></a>00006 <span class="comment"> * mmdl is distributed without any warranty under the </span>
<a name="l00007"></a>00007 <span class="comment"> * GNU General Public License (GPL) v2 &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00008"></a>00008 <span class="comment"> */</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="preprocessor">#ifndef bvpfe_domain_H_</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span><span class="preprocessor">#define bvpfe_domain_H_</span>
<a name="l00012"></a>00012 <span class="preprocessor"></span>
<a name="l00013"></a>00013 <span class="comment">//#define EIGEN_YES_I_KNOW_SPARSE_MODULE_IS_NOT_STABLE_YET</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;Eigen/Dense&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;Eigen/Sparse&gt;</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="comment">//#include &lt;Eigen/Sparse&gt;</span>
<a name="l00019"></a>00019 <span class="comment">//#include &lt;mmdl/BVP/UmfPackSupport.h&gt;</span>
<a name="l00020"></a>00020 <span class="comment">//#include &quot;mmdl/BVP/SuperLUSupport.h&quot;</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;mmdl/Quadrature/Quadrature.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;mmdl/Utilities/SequentialOutputFile.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;mmdl/Utilities/UniqueOutputFile.h&gt;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;mmdl/BVP/Node.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;mmdl/BVP/Tetrahedron.h&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;mmdl/BVP/Triangle.h&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;mmdl/BVP/Face.h&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;mmdl/BVP/SearchData.h&quot;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="comment">//#include &quot;SparseLib/CG.h&quot;</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;boost/ptr_container/ptr_vector.hpp&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;boost/ptr_container/ptr_map.hpp&gt;</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="keyword">namespace </span>bvpfe{
<a name="l00044"></a>00044         
<a name="l00045"></a>00045         
<a name="l00046"></a><a class="code" href="classbvpfe_1_1_domain.html">00046</a>         <span class="keyword">class </span><a class="code" href="classbvpfe_1_1_domain.html">Domain</a> {
<a name="l00047"></a>00047                 
<a name="l00048"></a>00048                 <span class="keyword">enum</span> {dim=3};
<a name="l00049"></a>00049                 
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;mmdl/BVP/commonTypeDefs.h&gt;</span>
<a name="l00051"></a>00051                 
<a name="l00052"></a>00052         <span class="keyword">public</span>:
<a name="l00053"></a>00053                 <span class="keyword">typedef</span> boost::ptr_vector&lt;Node&lt;dim&gt; &gt;  NodeContainerType;
<a name="l00054"></a>00054                 <span class="keyword">typedef</span> boost::ptr_vector&lt;Tetrahedron&gt; TetContainerType;
<a name="l00055"></a>00055                 <span class="keyword">typedef</span> boost::ptr_vector&lt;Triangle&gt;    TriContainerType;
<a name="l00056"></a>00056                 <span class="keyword">typedef</span> boost::ptr_map&lt;size_t,Face&gt;    FaceContainerType;
<a name="l00057"></a>00057                 <span class="keyword">typedef</span> std::pair&lt;bool,Tetrahedron*&gt;   isTetrahedronType;
<a name="l00058"></a>00058                 
<a name="l00059"></a>00059                 <span class="keyword">typedef</span> std::pair&lt; unsigned int, std::pair&lt;unsigned int, double&gt; &gt; inputBCsType;  
<a name="l00060"></a>00060                 
<a name="l00061"></a>00061                 
<a name="l00062"></a>00062         <span class="keyword">public</span>:
<a name="l00063"></a>00063                 NodeContainerType nodeContainer;                  <span class="comment">// container for the nodes&#39; pointers</span>
<a name="l00064"></a>00064                 TetContainerType tetContainer;                   <span class="comment">// container for the tetrahedrons&#39; pointers</span>
<a name="l00065"></a>00065                 std::vector&lt;Triangle*&gt; triContainer;
<a name="l00066"></a>00066                 
<a name="l00067"></a>00067                 std::vector &lt;inputBCsType&gt; inputBCsContainer , usrBCsContainer;      <span class="comment">// stores the input displacement BCs from the BC_0.txt file</span>
<a name="l00068"></a>00068                 
<a name="l00069"></a>00069                 
<a name="l00070"></a>00070                 std::set&lt;unsigned int&gt; cutTrisSet;     <span class="comment">// triangles IDs that has dislocation segments cutting them</span>
<a name="l00071"></a>00071                 
<a name="l00072"></a>00072 <span class="preprocessor">#include &lt;mmdl/BVP/outputVTK.h&gt;</span>         
<a name="l00073"></a>00073                 
<a name="l00074"></a>00074                 
<a name="l00075"></a>00075         <span class="keyword">private</span>:
<a name="l00076"></a>00076                 FaceContainerType faceContainer;                 <span class="comment">// container for the faces pointers</span>
<a name="l00077"></a>00077                 
<a name="l00078"></a>00078                 std::vector&lt;double&gt; Finf;                  <span class="comment">// holds the r.h.s. traction (infinite + external) force vector for all the nodes</span>
<a name="l00079"></a>00079                 
<a name="l00080"></a>00080                 
<a name="l00081"></a>00081                 <span class="comment">//TriContainerType triContainer;                 // container for triangle pointers</span>
<a name="l00082"></a>00082                 <span class="comment">//std::vector&lt;Triangle*&gt; triContainer;</span>
<a name="l00083"></a>00083                 
<a name="l00084"></a>00084                 std::map&lt;bvpfe::Face*,std::vector&lt;double&gt; &gt; facesWtraction;    <span class="comment">// container for the faces that have traction, and their traction vector</span>
<a name="l00085"></a>00085                 
<a name="l00086"></a>00086                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sysDim;                             <span class="comment">// dimension of the global linear system       </span>
<a name="l00087"></a>00087                 
<a name="l00088"></a>00088                 <span class="keyword">public</span> :
<a name="l00089"></a>00089                 <a class="code" href="classbvpfe_1_1_domain.html">Domain</a> () {}
<a name="l00090"></a>00090                 
<a name="l00091"></a>00091                 <span class="comment">//==================================================================================</span>
<a name="l00092"></a>00092                 <span class="comment">// function to read the mesh data from input files mesh.*</span>
<a name="l00093"></a>00093                 <span class="comment">//==================================================================================</span>
<a name="l00094"></a>00094                 
<a name="l00095"></a>00095                 <span class="keywordtype">void</span> readMesh(){
<a name="l00096"></a>00096                         
<a name="l00097"></a>00097                         readNodes();
<a name="l00098"></a>00098                         
<a name="l00099"></a>00099                         Finf.resize(nodeContainer.size()*3, 0.0);
<a name="l00100"></a>00100                         
<a name="l00101"></a>00101                         readVolElements();
<a name="l00102"></a>00102                         
<a name="l00103"></a>00103                         readSurfElements();
<a name="l00104"></a>00104                         
<a name="l00105"></a>00105                         outputMesh();
<a name="l00106"></a>00106                         
<a name="l00107"></a>00107                         <span class="comment">//output();</span>
<a name="l00108"></a>00108                         
<a name="l00109"></a>00109                         <span class="comment">//output_T_File();</span>
<a name="l00110"></a>00110                 }
<a name="l00111"></a>00111                 
<a name="l00112"></a>00112                 <span class="comment">//==================================================================================</span>
<a name="l00113"></a>00113                 <span class="comment">// ---------- function to read &amp; store the nodes data in Node objects and container ---------------</span>
<a name="l00114"></a>00114                 <span class="comment">//==================================================================================</span>
<a name="l00115"></a>00115                 
<a name="l00116"></a>00116                 <span class="keywordtype">void</span> readNodes()
<a name="l00117"></a>00117                 {
<a name="l00118"></a>00118                         <span class="comment">// int nNodes , d1, d2 , d3, in; // Giacomo 09-30-2011</span>
<a name="l00119"></a>00119                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nNodes , d1, d2 , d3, in;
<a name="l00120"></a>00120                         VectorDim tempP; 
<a name="l00121"></a>00121                         
<a name="l00122"></a>00122                         FILE *fp =fopen(<span class="stringliteral">&quot;mesh.node&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l00123"></a>00123                         
<a name="l00124"></a>00124                         assert(fscanf (fp, <span class="stringliteral">&quot;%u%u%u%u&quot;</span>, &amp;nNodes , &amp;d1, &amp;d2, &amp;d3)==4);
<a name="l00125"></a>00125                         
<a name="l00126"></a>00126                         <span class="keywordflow">if</span> ((d1!=3)&amp;&amp;(d2!=0)&amp;&amp;(d3!=0)) assert(0 &amp;&amp;<span class="stringliteral">&quot;Error in .node file format&quot;</span>);
<a name="l00127"></a>00127                         
<a name="l00128"></a>00128                         <span class="keywordtype">float</span> X[3];
<a name="l00129"></a>00129                         
<a name="l00130"></a>00130                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i&lt; nNodes; i++){
<a name="l00131"></a>00131                                 assert(fscanf (fp, <span class="stringliteral">&quot;%u%f%f%f&quot;</span>, &amp;in , &amp;X[0], &amp;X[1], &amp;X[2])==4);
<a name="l00132"></a>00132                                 
<a name="l00133"></a>00133                                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii = 0; ii&lt;3; ii++) {tempP(ii) = X[ii];}
<a name="l00134"></a>00134                                 
<a name="l00135"></a>00135                                 std::auto_ptr&lt;Node&lt;dim&gt; &gt; pNode (<span class="keyword">new</span> <a class="code" href="classbvpfe_1_1_node.html">Node&lt;dim&gt;</a>(tempP) );
<a name="l00136"></a>00136                                 <span class="keywordflow">if</span>(pNode-&gt;sID != in) assert(0&amp;&amp;<span class="stringliteral">&quot;Error in .node file format. use -z option when creating the mesh to start numbering from 0&quot;</span>);
<a name="l00137"></a>00137                                 nodeContainer.push_back(pNode);
<a name="l00138"></a>00138                         }
<a name="l00139"></a>00139                         
<a name="l00140"></a>00140                         fclose(fp);
<a name="l00141"></a>00141                         
<a name="l00142"></a>00142                 }
<a name="l00143"></a>00143                 
<a name="l00144"></a>00144                 <span class="comment">//==================================================================================</span>
<a name="l00145"></a>00145                 <span class="comment">//----------------- function to read &amp; distribute the volume elements data ------------</span>
<a name="l00146"></a>00146                 <span class="comment">//==================================================================================</span>
<a name="l00147"></a>00147                 
<a name="l00148"></a>00148                 <span class="keywordtype">void</span> readVolElements()
<a name="l00149"></a>00149                 {
<a name="l00150"></a>00150                         
<a name="l00151"></a>00151                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nTets , d1, nn , ti , nt;
<a name="l00152"></a>00152                         
<a name="l00153"></a>00153                         FILE *fTet =fopen(<span class="stringliteral">&quot;mesh.ele&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l00154"></a>00154                         FILE *fneigh =fopen(<span class="stringliteral">&quot;mesh.neigh&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l00155"></a>00155                         
<a name="l00156"></a>00156                         assert(fscanf (fTet, <span class="stringliteral">&quot;%u%u%u&quot;</span>, &amp;nTets , &amp;nn, &amp;d1)==3);
<a name="l00157"></a>00157                         <span class="keywordflow">if</span> ((nn!=4)&amp;&amp;(d1!=0)) assert(0&amp;&amp;<span class="stringliteral">&quot;Error in .ele file format&quot;</span>);
<a name="l00158"></a>00158                         
<a name="l00159"></a>00159                         assert(fscanf (fneigh, <span class="stringliteral">&quot;%u%u&quot;</span>,  &amp;nt, &amp;nn)==2);
<a name="l00160"></a>00160                         <span class="keywordflow">if</span> ((nn!=4)&amp;&amp;(nt!=nTets)) assert(0&amp;&amp;<span class="stringliteral">&quot;Error in .neigh file format&quot;</span>);
<a name="l00161"></a>00161                         
<a name="l00162"></a>00162                         <span class="keywordtype">int</span> neighbor[4];
<a name="l00163"></a>00163                         <span class="keywordtype">int</span> tetNodes[4];
<a name="l00164"></a>00164                         
<a name="l00165"></a>00165                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nTets; i++) {
<a name="l00166"></a>00166                                 
<a name="l00167"></a>00167                                 std::auto_ptr&lt;Tetrahedron&gt; pTet (<span class="keyword">new</span> <a class="code" href="classbvpfe_1_1_tetrahedron.html">Tetrahedron</a> ); 
<a name="l00168"></a>00168                                 
<a name="l00169"></a>00169                                 assert(fscanf (fneigh, <span class="stringliteral">&quot;%u%d%d%d%d&quot;</span>,  &amp;ti, &amp;neighbor[0], &amp;neighbor[1], &amp;neighbor[2], &amp;neighbor[3])==5);
<a name="l00170"></a>00170                                 assert(fscanf (fTet, <span class="stringliteral">&quot;%u%d%d%d%d&quot;</span>,  &amp;ti, &amp;tetNodes[0], &amp;tetNodes[1], &amp;tetNodes[2], &amp;tetNodes[3])==5);   
<a name="l00171"></a>00171                                 
<a name="l00172"></a>00172                                 <span class="keywordflow">if</span>(pTet-&gt;sID != ti) assert(0&amp;&amp;<span class="stringliteral">&quot;Error in .ele or .neigh file format. use -z option when creating the mesh to start numbering from 0&quot;</span>);
<a name="l00173"></a>00173                                 
<a name="l00174"></a>00174                                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j&lt;nn; j++) {
<a name="l00175"></a>00175                                         pTet-&gt;insertNode(&amp;nodeContainer[tetNodes[j]]); <span class="comment">// save the node ptr in the element&#39;s eleNodes array</span>
<a name="l00176"></a>00176                                 }
<a name="l00177"></a>00177                                 
<a name="l00178"></a>00178                                 <span class="comment">//----------- set neighbor elements -----------------</span>
<a name="l00179"></a>00179                                 pTet-&gt;addNeighbor(neighbor);
<a name="l00180"></a>00180                                 
<a name="l00181"></a>00181                                 <span class="comment">//--------- set the nodes neighborlist ---------</span>
<a name="l00182"></a>00182                                 pTet-&gt;setNodesNeighbors();
<a name="l00183"></a>00183                                 
<a name="l00184"></a>00184                                 <span class="comment">//assert(tetContainer.insert(std::make_pair(pTet-&gt;sID,pTet)).second);</span>
<a name="l00185"></a>00185                                 tetContainer.push_back(pTet);
<a name="l00186"></a>00186                         }
<a name="l00187"></a>00187                         
<a name="l00188"></a>00188                         fclose(fTet);
<a name="l00189"></a>00189                         fclose(fneigh);
<a name="l00190"></a>00190                 }
<a name="l00191"></a>00191                 
<a name="l00192"></a>00192                 <span class="comment">//==================================================================================</span>
<a name="l00193"></a>00193                 <span class="comment">//------------ function to read &amp; distribute the triangular surface elements data----------</span>
<a name="l00194"></a>00194                 <span class="comment">//==================================================================================</span>
<a name="l00195"></a>00195                 
<a name="l00196"></a>00196                 <span class="keywordtype">void</span> readSurfElements()
<a name="l00197"></a>00197                 {
<a name="l00198"></a>00198                         <span class="keywordtype">int</span> triNodes[3];                        
<a name="l00199"></a>00199                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nTris , di , iFc, iTet , ti;
<a name="l00200"></a>00200                         
<a name="l00201"></a>00201                         FILE *fTri =fopen(<span class="stringliteral">&quot;mesh.face&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l00202"></a>00202                         
<a name="l00203"></a>00203                         assert(fscanf (fTri, <span class="stringliteral">&quot;%u%u&quot;</span>, &amp;nTris , &amp;di)==2);
<a name="l00204"></a>00204                         
<a name="l00205"></a>00205                         <span class="keywordflow">if</span> (di!=0) assert(0&amp;&amp;<span class="stringliteral">&quot;Error in .face file format&quot;</span>);
<a name="l00206"></a>00206                         
<a name="l00207"></a>00207                         <a class="code" href="classbvpfe_1_1_triangle.html">Triangle</a>* pTri;
<a name="l00208"></a>00208                         
<a name="l00209"></a>00209                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iTri = 0; iTri &lt; nTris; iTri++ ){
<a name="l00210"></a>00210                                 assert(fscanf (fTri, <span class="stringliteral">&quot;%u%d%d%d%u%u&quot;</span>, &amp;ti , &amp;triNodes[0], &amp;triNodes[1], &amp;triNodes[2], &amp;iTet  , &amp;iFc )==6);
<a name="l00211"></a>00211                                 
<a name="l00212"></a>00212                                 <span class="comment">//----------- if the face does NOT exist, creat it ----------</span>
<a name="l00213"></a>00213                                 <span class="keywordflow">if</span>(faceContainer.find(iFc) == faceContainer.end()) {
<a name="l00214"></a>00214                                         std::auto_ptr&lt;Face&gt; pFace (<span class="keyword">new</span> <a class="code" href="classbvpfe_1_1_face.html">Face</a>);
<a name="l00215"></a>00215                                         assert(faceContainer.insert(iFc,pFace).second);
<a name="l00216"></a>00216                                 }
<a name="l00217"></a>00217                                 
<a name="l00218"></a>00218                                 <span class="comment">//---------- add triangles ---------</span>
<a name="l00219"></a>00219                                 pTri = <span class="keyword">new</span> <a class="code" href="classbvpfe_1_1_triangle.html">Triangle</a>;
<a name="l00220"></a>00220                                 
<a name="l00221"></a>00221                                 <span class="keywordflow">if</span>(pTri-&gt;sID != ti) {
<a name="l00222"></a>00222                                         assert(0&amp;&amp;<span class="stringliteral">&quot;Error in .face file format. use -z option when creating the mesh to start numbering from 0&quot;</span>);
<a name="l00223"></a>00223                                 }
<a name="l00224"></a>00224                                 
<a name="l00225"></a>00225                                 
<a name="l00226"></a>00226                                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j&lt;3; j++ ) {      <span class="comment">// insert triangle nodes</span>
<a name="l00227"></a>00227                                         nodeContainer[triNodes[j]].isBoundaryNode=<span class="keyword">true</span>;
<a name="l00228"></a>00228                                         pTri-&gt;insertNode(&amp;nodeContainer[triNodes[j]]);
<a name="l00229"></a>00229                                         nodeContainer[triNodes[j]].triIDs.push_back(pTri-&gt;sID);
<a name="l00230"></a>00230                                 }   
<a name="l00231"></a>00231                                 
<a name="l00232"></a>00232                                 triContainer.push_back(pTri);
<a name="l00233"></a>00233                                 
<a name="l00234"></a>00234                                 pTri-&gt;outNormal = pTri-&gt;triNormal();                       <span class="comment">// set the outward normal for the triangle</span>
<a name="l00235"></a>00235                                 
<a name="l00236"></a>00236                                 faceContainer.at(iFc).insertTri(pTri);                     <span class="comment">// insert triangle in the face</span>
<a name="l00237"></a>00237                                 
<a name="l00238"></a>00238                                 <span class="comment">// ------------ set neighbor tetrahedron for the face triangle ----------------</span>
<a name="l00239"></a>00239                                 
<a name="l00240"></a>00240                                 pTri-&gt;neighTetIndx = iTet;         <span class="comment">// index of the triangle&#39;s neighbor tetrahedron                      </span>
<a name="l00241"></a>00241                                 tetContainer[iTet].insertSurfTri(pTri);   <span class="comment">// set tetrahedron&#39;s neighbor surface triangle</span>
<a name="l00242"></a>00242                         }
<a name="l00243"></a>00243                         
<a name="l00244"></a>00244                         setNeighborTriangles();                 <span class="comment">// set for each triangle an array of pointers to the 3 neighbor triangles</span>
<a name="l00245"></a>00245                         
<a name="l00246"></a>00246                         fclose(fTri);
<a name="l00247"></a>00247                 }
<a name="l00248"></a>00248                 
<a name="l00249"></a>00249                 <span class="comment">//===================================================================================</span>
<a name="l00250"></a>00250                 <span class="comment">// function to set the 3 neighbor triangles for each surface triangle</span>
<a name="l00251"></a>00251                 <span class="comment">//===================================================================================</span>
<a name="l00252"></a>00252                 
<a name="l00253"></a>00253                 <span class="keywordtype">void</span> setNeighborTriangles(){
<a name="l00254"></a>00254                         
<a name="l00255"></a>00255                         <span class="comment">//Triangle* pTri1, pTri2;</span>
<a name="l00256"></a>00256                         
<a name="l00257"></a>00257                         Eigen::Matrix&lt;size_t,2,3&gt;   edgi , edgj; 
<a name="l00258"></a>00258                         
<a name="l00259"></a>00259                         <span class="comment">//unsigned int indxi, indxj;</span>
<a name="l00260"></a>00260                         
<a name="l00261"></a>00261                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i&lt;(triContainer.size()-1); i++){
<a name="l00262"></a>00262                                 
<a name="l00263"></a>00263                                 <span class="comment">//----------- take here specific order, and take the opposite for the pTri2 to avoid the need to sort</span>
<a name="l00264"></a>00264                                 edgi(0,0)=triContainer[i]-&gt;eleNodes[1]-&gt;sID;     edgi(1,0)=triContainer[i]-&gt;eleNodes[2]-&gt;sID;
<a name="l00265"></a>00265                                 edgi(0,1)=triContainer[i]-&gt;eleNodes[2]-&gt;sID;     edgi(1,1)=triContainer[i]-&gt;eleNodes[0]-&gt;sID;
<a name="l00266"></a>00266                                 edgi(0,2)=triContainer[i]-&gt;eleNodes[0]-&gt;sID;     edgi(1,2)=triContainer[i]-&gt;eleNodes[1]-&gt;sID;
<a name="l00267"></a>00267                                 
<a name="l00268"></a>00268                                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i+1; j&lt;triContainer.size(); j++){
<a name="l00269"></a>00269                                         
<a name="l00270"></a>00270                                         edgj(0,0)=triContainer[j]-&gt;eleNodes[2]-&gt;sID;     edgj(1,0)=triContainer[j]-&gt;eleNodes[1]-&gt;sID;
<a name="l00271"></a>00271                                         edgj(0,1)=triContainer[j]-&gt;eleNodes[1]-&gt;sID;     edgj(1,1)=triContainer[j]-&gt;eleNodes[0]-&gt;sID;
<a name="l00272"></a>00272                                         edgj(0,2)=triContainer[j]-&gt;eleNodes[0]-&gt;sID;     edgj(1,2)=triContainer[j]-&gt;eleNodes[2]-&gt;sID;
<a name="l00273"></a>00273                                         
<a name="l00274"></a>00274                                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii = 0; ii&lt;3; ii++){
<a name="l00275"></a>00275                                                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jj = 0; jj&lt;3; jj++){
<a name="l00276"></a>00276                                                         
<a name="l00277"></a>00277                                                         <span class="keywordflow">if</span>(edgi.col(ii) == edgj.col(jj)){
<a name="l00278"></a>00278                                                                 setTriCouples(i,j,ii,jj); <span class="keywordflow">break</span>;
<a name="l00279"></a>00279                                                         }
<a name="l00280"></a>00280                                                         
<a name="l00281"></a>00281                                                 }
<a name="l00282"></a>00282                                         }
<a name="l00283"></a>00283                                         
<a name="l00284"></a>00284                                 }
<a name="l00285"></a>00285                         }       
<a name="l00286"></a>00286                         
<a name="l00287"></a>00287                         
<a name="l00288"></a>00288                         <span class="comment">/*for (unsigned int i = 0; i&lt;triContainer.size(); i++){</span>
<a name="l00289"></a>00289 <span class="comment">                         std::cout&lt;&lt; &quot;Triangle: &quot;&lt;&lt; triContainer[i]-&gt;sID&lt;&lt; &quot; : &quot; &lt;&lt; triContainer[i]-&gt;neighbor[0]-&gt;sID &lt;&lt; &quot; &quot;&lt;&lt; triContainer[i]-&gt;neighbor[1]-&gt;sID &lt;&lt; &quot; &quot;</span>
<a name="l00290"></a>00290 <span class="comment">                         &lt;&lt; triContainer[i]-&gt;neighbor[2]-&gt;sID &lt;&lt; std::endl;</span>
<a name="l00291"></a>00291 <span class="comment">                         }*/</span>
<a name="l00292"></a>00292                         
<a name="l00293"></a>00293                         
<a name="l00294"></a>00294                 }
<a name="l00295"></a>00295                 
<a name="l00296"></a>00296                 <span class="comment">//==================================================================================</span>
<a name="l00297"></a>00297                 <span class="comment">// function to set 2 neighbor triangles as neighbors</span>
<a name="l00298"></a>00298                 <span class="comment">//===================================================================================</span>
<a name="l00299"></a>00299                 
<a name="l00300"></a>00300                 <span class="keywordtype">void</span> setTriCouples(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ti,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tj,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ni,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nj){
<a name="l00301"></a>00301                         
<a name="l00302"></a>00302                         <span class="comment">//-----temporary, and needs modification. Index modification is mainly becasue of different sequence convention for edgj </span>
<a name="l00303"></a>00303                         <span class="keywordflow">if</span>(nj==2) {nj=1;}
<a name="l00304"></a>00304                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nj==1) {nj=2;}
<a name="l00305"></a>00305                         
<a name="l00306"></a>00306                         <span class="comment">//std::cout &lt;&lt; ti &lt;&lt; &quot; &quot; &lt;&lt; tj &lt;&lt; &quot; &quot; &lt;&lt; ni &lt;&lt; &quot; &quot; &lt;&lt; nj &lt;&lt; std::endl;</span>
<a name="l00307"></a>00307                         
<a name="l00308"></a>00308                         triContainer[ti]-&gt;neighbor[ni] = triContainer[tj];
<a name="l00309"></a>00309                         triContainer[tj]-&gt;neighbor[nj] = triContainer[ti];
<a name="l00310"></a>00310                         
<a name="l00311"></a>00311                 }
<a name="l00312"></a>00312                 
<a name="l00313"></a>00313                 
<a name="l00314"></a>00314                 <span class="comment">//==================================================================================</span>
<a name="l00315"></a>00315                 <span class="comment">// function to read and store the input traction and displacement boundary conditions for the domain from BC_0.txt</span>
<a name="l00316"></a>00316                 <span class="comment">//===================================================================================</span>
<a name="l00317"></a>00317                 
<a name="l00318"></a>00318                 <span class="keywordtype">void</span> readInputBCs() {
<a name="l00319"></a>00319                         
<a name="l00320"></a>00320                         Eigen::Matrix &lt;float,dim,1&gt;  u , tr;
<a name="l00321"></a>00321                         Eigen::Matrix &lt;unsigned int,dim,1&gt; isBC; 
<a name="l00322"></a>00322                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ni;
<a name="l00323"></a>00323                         
<a name="l00324"></a>00324                         inputBCsType u_BC;
<a name="l00325"></a>00325                         
<a name="l00326"></a>00326                         FILE *fp =fopen(<span class="stringliteral">&quot;BCs_0.txt&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l00327"></a>00327                         
<a name="l00328"></a>00328                         <span class="keywordflow">while</span> (!feof(fp)) {
<a name="l00329"></a>00329                                 <span class="keywordflow">if</span>(fscanf(fp, <span class="stringliteral">&quot;%u%u%u%u%f%f%f%f%f%f&quot;</span>, &amp;ni,&amp;isBC(0), &amp;isBC(1), &amp;isBC(2),&amp;u(0),&amp;u(1),&amp;u(2),&amp;tr(0),&amp;tr(1),&amp;tr(2))==10){
<a name="l00330"></a>00330                                         <span class="keywordflow">if</span>(nodeContainer[ni].isBoundaryNode) {
<a name="l00331"></a>00331                                                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j&lt;3 ; j++) {
<a name="l00332"></a>00332                                                         <span class="comment">//if(isBC(j))  nodeContainer[ni].setBC(j ,double(u(j)) );</span>
<a name="l00333"></a>00333                                                         <span class="keywordflow">if</span>(isBC(j))  {
<a name="l00334"></a>00334                                                                 <span class="comment">//std::cout &lt;&lt; j &lt;&lt; &quot;   &quot; &lt;&lt; nodeContainer[ni].P(j) &lt;&lt; &quot;  &quot; &lt;&lt; double(u(j)) &lt;&lt; std::endl;</span>
<a name="l00335"></a>00335                                                                 u_BC.first = ni;
<a name="l00336"></a>00336                                                                 u_BC.second.first = j;
<a name="l00337"></a>00337                                                                 u_BC.second.second = double(u(j)) ;
<a name="l00338"></a>00338                                                                 inputBCsContainer.push_back(u_BC);
<a name="l00339"></a>00339                                                         }
<a name="l00340"></a>00340                                                         nodeContainer[ni].traction(j) = double(tr(j));
<a name="l00341"></a>00341                                                 }
<a name="l00342"></a>00342                                         }
<a name="l00343"></a>00343                                         <span class="keywordflow">else</span>  {assert(0&amp;&amp;<span class="stringliteral">&quot;inputting boundary condition for non-boundary node&quot;</span>);}
<a name="l00344"></a>00344                                 }
<a name="l00345"></a>00345                         }       
<a name="l00346"></a>00346                         
<a name="l00347"></a>00347                         fclose(fp);
<a name="l00348"></a>00348                 }
<a name="l00349"></a>00349                 
<a name="l00350"></a>00350                 <span class="comment">//==================================================================================</span>
<a name="l00351"></a>00351                 <span class="comment">// function to set the displacement boundary conditions for the domain</span>
<a name="l00352"></a>00352                 <span class="comment">// 1- Update the infinite medium displacement at domain nodes.</span>
<a name="l00353"></a>00353                 <span class="comment">// 2- set the the displacement BCs that were defined in the BC_0.txt file.</span>
<a name="l00354"></a>00354                 <span class="comment">// 3- Update user defined displacement BCs, if required. </span>
<a name="l00355"></a>00355                 <span class="comment">//===================================================================================</span>
<a name="l00356"></a>00356                 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00357"></a>00357                 <span class="keywordtype">void</span> setBoundaryConditions(<span class="keywordtype">bool</span> update_usr_defined_BCs ,<span class="keyword">const</span> T* <span class="keyword">const</span> pT) {
<a name="l00358"></a>00358                         
<a name="l00359"></a>00359                         <span class="comment">//------------------- remove old boundary conditions first &quot;just for safety&quot; ----------</span>
<a name="l00360"></a>00360                         removeBoundaryConditions();
<a name="l00361"></a>00361                         
<a name="l00362"></a>00362                         std::cout&lt;&lt;<span class="stringliteral">&quot;=======================================================================================&quot;</span>&lt;&lt;std::endl;
<a name="l00363"></a>00363                         <span class="comment">//-------------------- Calculate infinite medium displacement field --------------------</span>
<a name="l00364"></a>00364                         
<a name="l00365"></a>00365                         <span class="comment">//FILE *finfd =fopen(&quot;infDis.txt&quot;, &quot;w&quot;);</span>
<a name="l00366"></a>00366                         
<a name="l00367"></a>00367                         <span class="keywordtype">double</span> t0=clock();
<a name="l00368"></a>00368                         std::cout&lt;&lt;<span class="stringliteral">&quot;Calculate infinite medium displacement field......  &quot;</span>;
<a name="l00369"></a>00369                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dN=0; dN&lt;nodeContainer.size();++dN){
<a name="l00370"></a>00370                                 <span class="keywordflow">if</span>(nodeContainer[dN].isBoundaryNode) {
<a name="l00371"></a>00371                                   <span class="keywordflow">if</span>(nodeContainer[dN].triIDs.size() == 0) assert(0&amp;&amp;<span class="stringliteral">&quot;Error: Boundary node without triangle element index array&quot;</span>);
<a name="l00372"></a>00372                                         
<a name="l00373"></a>00373                                         VectorDim nodeNormal(VectorDim::Zero());
<a name="l00374"></a>00374                                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0;k&lt;nodeContainer[dN].triIDs.size();++k){
<a name="l00375"></a>00375                                                 nodeNormal+=triContainer[nodeContainer[dN].triIDs[k]]-&gt;outNormal;
<a name="l00376"></a>00376                                         }
<a name="l00377"></a>00377                                         assert(nodeNormal.norm()&gt;FLT_EPSILON);
<a name="l00378"></a>00378                                         nodeNormal.normalize();
<a name="l00379"></a>00379 
<a name="l00380"></a>00380                                 nodeContainer[dN].uInf=pT-&gt;displacement(nodeContainer[dN].P+10.0*nodeNormal,nodeNormal);
<a name="l00381"></a>00381 
<a name="l00382"></a>00382 <span class="comment">//                                nodeContainer[dN].uInf=pT-&gt;displacement(nodeContainer[dN].P,triContainer[nodeContainer[dN].triIDs[0]]-&gt;outNormal);</span>
<a name="l00383"></a>00383                                         
<a name="l00384"></a>00384                                         <span class="comment">//  fprintf (finfd, &quot;%u %f %f %f \n&quot;,dN , nodeContainer[dN].uInf(0) , nodeContainer[dN].uInf(1), nodeContainer[dN].uInf(2) );</span>
<a name="l00385"></a>00385                                 }
<a name="l00386"></a>00386                                 
<a name="l00387"></a>00387                                 
<a name="l00388"></a>00388                                 
<a name="l00389"></a>00389                         }
<a name="l00390"></a>00390                         std::cout&lt;&lt;<span class="stringliteral">&quot;DONE in&quot;</span>&lt;&lt;<span class="stringliteral">&quot;[&quot;</span>&lt;&lt;(clock()-t0)/CLOCKS_PER_SEC&lt;&lt;<span class="stringliteral">&quot; sec]&quot;</span>&lt;&lt;std::endl;
<a name="l00391"></a>00391                         
<a name="l00392"></a>00392                         <span class="comment">//fclose(finfd);</span>
<a name="l00393"></a>00393                         <span class="comment">//------------------- update input boundary conditions -------------------------------</span>
<a name="l00394"></a>00394                         
<a name="l00395"></a>00395                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;inputBCsContainer.size(); i++){
<a name="l00396"></a>00396                                 nodeContainer[inputBCsContainer[i].first].setBC( inputBCsContainer[i].second.first , inputBCsContainer[i].second.second );
<a name="l00397"></a>00397                         }
<a name="l00398"></a>00398                         
<a name="l00399"></a>00399                         <span class="comment">//----------------------- update the user defined boundary conditions, if needed -------------------------</span>
<a name="l00400"></a>00400                         
<a name="l00401"></a>00401 <span class="preprocessor">#ifdef UpdateBoundaryConditionsFile</span>
<a name="l00402"></a>00402 <span class="preprocessor"></span>                        <span class="keywordflow">if</span> (update_usr_defined_BCs)    usrBCsContainer = pT-&gt;update_usr_BCs();          <span class="comment">// store user defined boundary conditions</span>
<a name="l00403"></a>00403                         
<a name="l00404"></a>00404                         <span class="comment">// apply user defined boundary conditions</span>
<a name="l00405"></a>00405                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;usrBCsContainer.size(); i++){
<a name="l00406"></a>00406                                 nodeContainer[usrBCsContainer[i].first].setBC( usrBCsContainer[i].second.first , usrBCsContainer[i].second.second );
<a name="l00407"></a>00407                         }
<a name="l00408"></a>00408 <span class="preprocessor">#endif  </span>
<a name="l00409"></a>00409 <span class="preprocessor"></span>                        
<a name="l00410"></a>00410                 }
<a name="l00411"></a>00411                 
<a name="l00412"></a>00412                 <span class="comment">//========================================================================================</span>
<a name="l00413"></a>00413                 <span class="comment">// Function to set the boundary conditions for the BVP and then solve it</span>
<a name="l00414"></a>00414                 <span class="comment">//=======================================================================================</span>
<a name="l00415"></a>00415                 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00416"></a>00416                 <span class="keywordtype">void</span> update_BVP_Solution(<span class="keywordtype">bool</span> update_usr_BCs ,<span class="keyword">const</span> T* <span class="keyword">const</span> pT) {
<a name="l00417"></a>00417                         
<a name="l00418"></a>00418                   <span class="comment">//pT-&gt;findSegmentsCuttingTriangles();</span>
<a name="l00419"></a>00419                   
<a name="l00420"></a>00420                         <span class="comment">//------- Calculate infinte medium displacement, and set displacement boundary conditions ----------</span>
<a name="l00421"></a>00421                         setBoundaryConditions(update_usr_BCs , pT);
<a name="l00422"></a>00422                         
<a name="l00423"></a>00423                         <span class="comment">//--------------------- Solve the BVP -----------------------------------------------------------</span>
<a name="l00424"></a>00424                         solveBVP(<span class="keyword">true</span>,pT);
<a name="l00425"></a>00425                 }
<a name="l00426"></a>00426                 
<a name="l00427"></a>00427                 <span class="comment">//===================================================================================</span>
<a name="l00428"></a>00428                 <span class="comment">// function to assemble the global linear system, solve it, and distribute nodal displacement</span>
<a name="l00429"></a>00429                 <span class="comment">//===================================================================================</span>
<a name="l00430"></a>00430                 
<a name="l00431"></a>00431                 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00432"></a>00432                 <span class="keywordtype">void</span> solveBVP(<span class="keywordtype">bool</span> dislocations_Stress,<span class="keyword">const</span> T* <span class="keyword">const</span> pT)
<a name="l00433"></a>00433                 {
<a name="l00434"></a>00434                         <span class="keywordtype">double</span> t0;
<a name="l00435"></a>00435                         
<a name="l00436"></a>00436                         <span class="comment">//std::cout&lt;&lt;&quot;=======================================================================================&quot;&lt;&lt;std::endl;</span>
<a name="l00437"></a>00437                         <span class="comment">//-------------------- Calculate infinite medium displacement field --------------------</span>
<a name="l00438"></a>00438                         <span class="comment">/*</span>
<a name="l00439"></a>00439 <span class="comment">                         t0=clock();</span>
<a name="l00440"></a>00440 <span class="comment">                         std::cout&lt;&lt;&quot;Calculate infinite medium displacement field......  &quot;;</span>
<a name="l00441"></a>00441 <span class="comment">                         for (unsigned int dN=0; dN&lt;nodeContainer.size();++dN){</span>
<a name="l00442"></a>00442 <span class="comment">                         if(nodeContainer[dN].isBoundaryNode) nodeContainer[dN].uInf=pT-&gt;displacement(nodeContainer[dN].P);</span>
<a name="l00443"></a>00443 <span class="comment">                         }</span>
<a name="l00444"></a>00444 <span class="comment">                         std::cout&lt;&lt;&quot;DONE in&quot;&lt;&lt;&quot;[&quot;&lt;&lt;(clock()-t0)/CLOCKS_PER_SEC&lt;&lt;&quot; sec]&quot;&lt;&lt;std::endl;</span>
<a name="l00445"></a>00445 <span class="comment">                         </span>
<a name="l00446"></a>00446 <span class="comment">                         */</span>
<a name="l00447"></a>00447                         <span class="comment">//---------------------- initiate sparse system -------------------------</span>
<a name="l00448"></a>00448                         std::vector&lt;int&gt; rr, cc;
<a name="l00449"></a>00449                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  nz;
<a name="l00450"></a>00450                         
<a name="l00451"></a>00451                         
<a name="l00452"></a>00452                         <span class="keywordtype">double</span> tS1=clock();
<a name="l00453"></a>00453                         <span class="comment">//------ set the equation number for each dof based on the boundary conditions</span>
<a name="l00454"></a>00454                         setEquationNumbers();
<a name="l00455"></a>00455                         
<a name="l00456"></a>00456                         <span class="comment">//-------- initiate the sparse system ------------------</span>
<a name="l00457"></a>00457                         
<a name="l00458"></a>00458                         initiateSparseSystem(nz, rr , cc);
<a name="l00459"></a>00459                         
<a name="l00460"></a>00460                         <span class="comment">//--------------------- Build the sparse matrix ------------------------</span>
<a name="l00461"></a>00461                         
<a name="l00462"></a>00462                         Eigen::VectorXi nColNZs(sysDim);           <span class="comment">// number of nonzero elements on each column of the sparse matrix</span>
<a name="l00463"></a>00463                         
<a name="l00464"></a>00464                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;sysDim; i++) {nColNZs(i)=0;}            <span class="comment">// initialize</span>
<a name="l00465"></a>00465                     
<a name="l00466"></a>00466                     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nz; i++) {
<a name="l00467"></a>00467                                 ++nColNZs (cc[i]);
<a name="l00468"></a>00468                     }
<a name="l00469"></a>00469                     
<a name="l00470"></a>00470                     Eigen::VectorXd U(sysDim);           <span class="comment">// Displacement vector</span>
<a name="l00471"></a>00471                     Eigen::VectorXd F(sysDim);           <span class="comment">// r.h.s. force vector</span>
<a name="l00472"></a>00472                     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;sysDim; i++) {F(i) = 0.0e+00; U(i) =  0.0e+00;}
<a name="l00473"></a>00473                     
<a name="l00474"></a>00474                     Eigen::SparseMatrix&lt;double&gt; K(sysDim,sysDim);         <span class="comment">// The sparse global stiffness matrix</span>
<a name="l00475"></a>00475                     K.reserve(nColNZs);
<a name="l00476"></a>00476                     
<a name="l00477"></a>00477                     
<a name="l00478"></a>00478                     <span class="comment">//-------- Assemble the the linear system ---------</span>
<a name="l00479"></a>00479                     t0=clock();
<a name="l00480"></a>00480                     std::cout&lt;&lt;<span class="stringliteral">&quot;Assembling stiffness matrix.......................  &quot;</span>;
<a name="l00481"></a>00481                     
<a name="l00482"></a>00482                     assemble (K,F);    <span class="comment">// assmble stiffness matrix and force vector from displacment BCs</span>
<a name="l00483"></a>00483                     
<a name="l00484"></a>00484                     K.makeCompressed();   
<a name="l00485"></a>00485                     std::cout&lt;&lt;<span class="stringliteral">&quot;DONE in&quot;</span>&lt;&lt;<span class="stringliteral">&quot;[&quot;</span>&lt;&lt;(clock()-t0)/CLOCKS_PER_SEC&lt;&lt;<span class="stringliteral">&quot; sec]&quot;</span>&lt;&lt;std::endl;
<a name="l00486"></a>00486                     
<a name="l00487"></a>00487                     
<a name="l00488"></a>00488                     <span class="comment">//-------- Assemble the r.h.s force vector from infinite and external traction ---------</span>
<a name="l00489"></a>00489                     
<a name="l00490"></a>00490                     <span class="keywordflow">if</span> (dislocations_Stress){
<a name="l00491"></a>00491                                 t0=clock();
<a name="l00492"></a>00492                                 std::cout&lt;&lt;<span class="stringliteral">&quot;Assembling infinite traction r.h.s. vector .......  &quot;</span>;
<a name="l00493"></a>00493                                 assembleInfiniteTraction (F,pT);   <span class="comment">// assemble force vector from infinite medium surface traction</span>
<a name="l00494"></a>00494                                 std::cout&lt;&lt;<span class="stringliteral">&quot;DONE in&quot;</span>&lt;&lt;<span class="stringliteral">&quot;[&quot;</span>&lt;&lt;(clock()-t0)/CLOCKS_PER_SEC&lt;&lt;<span class="stringliteral">&quot; sec]&quot;</span>&lt;&lt;std::endl;
<a name="l00495"></a>00495                     } 
<a name="l00496"></a>00496                         
<a name="l00497"></a>00497                     <span class="comment">//---------------- Solving linear system ---------------------------</span>
<a name="l00498"></a>00498                     t0=clock();
<a name="l00499"></a>00499                     std::cout&lt;&lt;<span class="stringliteral">&quot;Solving linear system ............................  &quot;</span>;
<a name="l00500"></a>00500                         
<a name="l00501"></a>00501                     Eigen::ConjugateGradient&lt;Eigen::SparseMatrix&lt;double&gt; &gt; solver;
<a name="l00502"></a>00502                     solver.setTolerance(1.0e-8);
<a name="l00503"></a>00503                     <span class="comment">//std::cout &lt;&lt;&quot;Eigen_tolerance &quot;&lt;&lt; solver.tolerance() &lt;&lt; std::endl;</span>
<a name="l00504"></a>00504                     U = solver.compute(K).solve(F);
<a name="l00505"></a>00505                     
<a name="l00506"></a>00506                     std::cout&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt; solver.info() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> ;
<a name="l00507"></a>00507                     
<a name="l00508"></a>00508                     <span class="keywordflow">if</span>(solver.info()!= Eigen::Success) {
<a name="l00509"></a>00509                       std::cout &lt;&lt; <span class="stringliteral">&quot;Solving BVP failed: &quot;</span> &lt;&lt; solver.info() &lt;&lt; std::endl;
<a name="l00510"></a>00510                       assert(0);
<a name="l00511"></a>00511                     }
<a name="l00512"></a>00512                     
<a name="l00513"></a>00513                     std::cout&lt;&lt;<span class="stringliteral">&quot;DONE in&quot;</span>&lt;&lt;<span class="stringliteral">&quot;[&quot;</span>&lt;&lt;(clock()-t0)/CLOCKS_PER_SEC&lt;&lt;<span class="stringliteral">&quot; sec]&quot;</span>&lt;&lt;std::endl;
<a name="l00514"></a>00514                     
<a name="l00515"></a>00515                     <span class="comment">//std::cout&lt;&lt;&quot;Sparse Eigen time= &quot;&lt;&lt;(clock()-tS0)/CLOCKS_PER_SEC&lt;&lt;&quot; [sec]&quot;&lt;&lt;std::endl;</span>
<a name="l00516"></a>00516                     
<a name="l00517"></a>00517                     
<a name="l00518"></a>00518                     
<a name="l00519"></a>00519                     <span class="comment">//-------------- distribute displacement to nodes -----------                       </span>
<a name="l00520"></a>00520                     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0 ; i &lt; nodeContainer.size(); i++ )
<a name="l00521"></a>00521                     {   
<a name="l00522"></a>00522                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;dim; j++)
<a name="l00523"></a>00523                                 {
<a name="l00524"></a>00524                                         <span class="keywordflow">if</span> (!nodeContainer[i].isBC(j)) {nodeContainer[i].u(j) = U(nodeContainer[i].eqnNumber(j));}
<a name="l00525"></a>00525                                 }
<a name="l00526"></a>00526                                 nodeContainer[i].displaceNode();
<a name="l00527"></a>00527                                 <span class="comment">//std::cout&lt;&lt; &quot;node: &quot;&lt;&lt; nodeContainer[i].sID&lt;&lt; &quot;: &quot; &lt;&lt;nodeContainer[i].u.value[0]&lt;&lt; &quot; &quot; &lt;&lt;nodeContainer[i].u.value[1]&lt;&lt; &quot; &quot; &lt;&lt;nodeContainer[i].u.value[2] &lt;&lt; std::endl;</span>
<a name="l00528"></a>00528                     }
<a name="l00529"></a>00529                     
<a name="l00530"></a>00530                     std::cout&lt;&lt;<span class="stringliteral">&quot;Total BVP solution time=    &quot;</span>&lt;&lt;(clock()-tS1)/CLOCKS_PER_SEC&lt;&lt;<span class="stringliteral">&quot; [sec]&quot;</span>&lt;&lt;std::endl;
<a name="l00531"></a>00531                     std::cout&lt;&lt;<span class="stringliteral">&quot;=======================================================================================&quot;</span>&lt;&lt;std::endl;
<a name="l00532"></a>00532 <span class="preprocessor">#ifdef Contact_Loading</span>
<a name="l00533"></a>00533 <span class="preprocessor"></span>                    <span class="keywordflow">while</span>(pT-&gt;overConstraintNodes()) {
<a name="l00534"></a>00534                                 t0=clock();
<a name="l00535"></a>00535                                 std::cout&lt;&lt;<span class="stringliteral">&quot;Resolving BVP .........................................  &quot;</span>;
<a name="l00536"></a>00536                                 reSolveBVP(<span class="keyword">true</span>);
<a name="l00537"></a>00537                                 std::cout&lt;&lt;<span class="stringliteral">&quot;DONE in&quot;</span>&lt;&lt;<span class="stringliteral">&quot;[&quot;</span>&lt;&lt;(clock()-t0)/CLOCKS_PER_SEC&lt;&lt;<span class="stringliteral">&quot; sec]&quot;</span>&lt;&lt;std::endl;
<a name="l00538"></a>00538                     }
<a name="l00539"></a>00539 <span class="preprocessor">#endif  </span>
<a name="l00540"></a>00540 <span class="preprocessor"></span>                    std::cout&lt;&lt;<span class="stringliteral">&quot;=======================================================================================&quot;</span>&lt;&lt;std::endl;
<a name="l00541"></a>00541                     <span class="comment">//output();                 </span>
<a name="l00542"></a>00542                     <span class="comment">//writeVTK_file (pT);</span>
<a name="l00543"></a>00543                 }
<a name="l00544"></a>00544                 
<a name="l00545"></a>00545                 
<a name="l00546"></a>00546                 <span class="comment">//===================================================================================</span>
<a name="l00547"></a>00547                 <span class="comment">// function to assemble the global linear system, solve it, and distribute nodal displacement</span>
<a name="l00548"></a>00548                 <span class="comment">//===================================================================================</span>
<a name="l00549"></a>00549                 
<a name="l00550"></a>00550                 <span class="keywordtype">void</span> reSolveBVP(<span class="keywordtype">bool</span> dislocations_Stress)
<a name="l00551"></a>00551                 {
<a name="l00552"></a>00552                         std::vector&lt;int&gt; rr, cc;
<a name="l00553"></a>00553                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  nz;
<a name="l00554"></a>00554                         
<a name="l00555"></a>00555                         
<a name="l00556"></a>00556                         <span class="comment">//double tS1=clock();</span>
<a name="l00557"></a>00557                         <span class="comment">//------ set the equation number for each dof based on the boundary conditions</span>
<a name="l00558"></a>00558                         setEquationNumbers();
<a name="l00559"></a>00559                         
<a name="l00560"></a>00560                         <span class="comment">//-------- initiate the sparse system ------------------</span>
<a name="l00561"></a>00561                         
<a name="l00562"></a>00562                         initiateSparseSystem(nz, rr , cc);
<a name="l00563"></a>00563                         
<a name="l00564"></a>00564                         <span class="comment">//--------------------- Build the sparse matrix ------------------------</span>
<a name="l00565"></a>00565                         
<a name="l00566"></a>00566                         Eigen::VectorXi nColNZs(sysDim);           <span class="comment">// number of nonzero elements on each column of the sparse matrix</span>
<a name="l00567"></a>00567                         
<a name="l00568"></a>00568                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;sysDim; i++) {nColNZs(i)=0;}            <span class="comment">// initialize</span>
<a name="l00569"></a>00569                         
<a name="l00570"></a>00570                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nz; i++) {
<a name="l00571"></a>00571                                 ++nColNZs (cc[i]);
<a name="l00572"></a>00572                         }
<a name="l00573"></a>00573                         
<a name="l00574"></a>00574                         Eigen::VectorXd U(sysDim);           <span class="comment">// Displacement vector</span>
<a name="l00575"></a>00575                         Eigen::VectorXd F(sysDim);           <span class="comment">// r.h.s. force vector</span>
<a name="l00576"></a>00576                         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;sysDim; i++) {F(i) = 0.0e+00; U(i) =  0.0e+00;}
<a name="l00577"></a>00577                         
<a name="l00578"></a>00578                         Eigen::SparseMatrix&lt;double&gt; K(sysDim,sysDim);         <span class="comment">// The sparse global stiffness matrix</span>
<a name="l00579"></a>00579                         K.reserve(nColNZs);
<a name="l00580"></a>00580                         
<a name="l00581"></a>00581                         
<a name="l00582"></a>00582                         <span class="comment">//-------- Assemble the the linear system ---------</span>
<a name="l00583"></a>00583                         
<a name="l00584"></a>00584                         assemble (K,F);    <span class="comment">// assmble stiffness matrix and force vector from displacment BCs</span>
<a name="l00585"></a>00585                         
<a name="l00586"></a>00586                         K.makeCompressed();   
<a name="l00587"></a>00587                         
<a name="l00588"></a>00588                         <span class="comment">//assembleTractionForce (F);   // assemble force vector from surface traction</span>
<a name="l00589"></a>00589                         
<a name="l00590"></a>00590                         <span class="keywordflow">if</span> (dislocations_Stress) copyTractionVector(F);
<a name="l00591"></a>00591                         
<a name="l00592"></a>00592                         <span class="comment">//double tS0=clock();</span>
<a name="l00593"></a>00593                         
<a name="l00594"></a>00594                         Eigen::ConjugateGradient&lt;Eigen::SparseMatrix&lt;double&gt; &gt; solver;
<a name="l00595"></a>00595                         U = solver.compute(K).solve(F);
<a name="l00596"></a>00596                         
<a name="l00597"></a>00597                         <span class="comment">//std::cout&lt;&lt;&quot;Sparse Eigen time= &quot;&lt;&lt;(clock()-tS0)/CLOCKS_PER_SEC&lt;&lt;&quot; [sec]&quot;&lt;&lt;std::endl;</span>
<a name="l00598"></a>00598                         <span class="comment">//std::cout&lt;&lt;&quot;Total BVP time=    &quot;&lt;&lt;(clock()-tS1)/CLOCKS_PER_SEC&lt;&lt;&quot; [sec]&quot;&lt;&lt;std::endl;</span>
<a name="l00599"></a>00599                         
<a name="l00600"></a>00600                         <span class="comment">//-------------- distribute displacement to nodes -----------                   </span>
<a name="l00601"></a>00601                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0 ; i &lt; nodeContainer.size(); i++ )
<a name="l00602"></a>00602                         {       
<a name="l00603"></a>00603                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;dim; j++)
<a name="l00604"></a>00604                                 {
<a name="l00605"></a>00605                                         <span class="keywordflow">if</span> (!nodeContainer[i].isBC(j)) {nodeContainer[i].u(j) = U(nodeContainer[i].eqnNumber(j));}
<a name="l00606"></a>00606                                 }
<a name="l00607"></a>00607                                 nodeContainer[i].displaceNode();
<a name="l00608"></a>00608                                 <span class="comment">//std::cout&lt;&lt; &quot;node: &quot;&lt;&lt; nodeContainer[i].sID&lt;&lt; &quot;: &quot; &lt;&lt;nodeContainer[i].u.value[0]&lt;&lt; &quot; &quot; &lt;&lt;nodeContainer[i].u.value[1]&lt;&lt; &quot; &quot; &lt;&lt;nodeContainer[i].u.value[2] &lt;&lt; std::endl;</span>
<a name="l00609"></a>00609                         }
<a name="l00610"></a>00610                         
<a name="l00611"></a>00611                         
<a name="l00612"></a>00612                         
<a name="l00613"></a>00613                 }
<a name="l00614"></a>00614                 
<a name="l00615"></a>00615                 <span class="comment">//=================================================================================================</span>
<a name="l00616"></a>00616                 <span class="comment">// Copy the r.h.s. traction (infinite and external) force vector that was calculated inside solveBVP() function</span>
<a name="l00617"></a>00617                 <span class="comment">//=================================================================================================</span>
<a name="l00618"></a>00618                 
<a name="l00619"></a>00619                 <span class="keywordtype">void</span> copyTractionVector(Eigen::VectorXd&amp; Fm) {
<a name="l00620"></a>00620                         
<a name="l00621"></a>00621                         <span class="keywordtype">int</span> qi;
<a name="l00622"></a>00622                         
<a name="l00623"></a>00623                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ni = 0; ni &lt; nodeContainer.size(); ni ++ ) {
<a name="l00624"></a>00624                                 
<a name="l00625"></a>00625                                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofi = 0; dofi&lt;3; dofi++){
<a name="l00626"></a>00626                                         
<a name="l00627"></a>00627                                         qi = nodeContainer[ni].eqnNumber(dofi);
<a name="l00628"></a>00628                                         
<a name="l00629"></a>00629                                         <span class="keywordflow">if</span> ( qi != -1) Fm(qi) = Fm(qi) + Finf[(ni*3)+dofi];
<a name="l00630"></a>00630                                         
<a name="l00631"></a>00631                                 }
<a name="l00632"></a>00632                                 
<a name="l00633"></a>00633                         }
<a name="l00634"></a>00634                 }
<a name="l00635"></a>00635                 
<a name="l00636"></a>00636                 <span class="comment">//===================================================================================</span>
<a name="l00637"></a>00637                 <span class="comment">// function to set the equation numbers for all dofs</span>
<a name="l00638"></a>00638                 <span class="comment">//===================================================================================</span>
<a name="l00639"></a>00639                 
<a name="l00640"></a>00640                 <span class="keywordtype">void</span> setEquationNumbers()
<a name="l00641"></a>00641                 {
<a name="l00642"></a>00642                         <span class="comment">//unsigned int dim = 3;       // 3 dofs</span>
<a name="l00643"></a>00643                         <span class="keywordtype">int</span> num;
<a name="l00644"></a>00644                         <a class="code" href="classbvpfe_1_1_node.html">bvpfe::Node&lt;dim&gt;</a>* pNode;
<a name="l00645"></a>00645                         
<a name="l00646"></a>00646                         num = -1;
<a name="l00647"></a>00647                         
<a name="l00648"></a>00648                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0 ; i &lt; nodeContainer.size(); i++ )
<a name="l00649"></a>00649                         {       
<a name="l00650"></a>00650                                 pNode = &amp;nodeContainer[i];
<a name="l00651"></a>00651                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;dim; j++)
<a name="l00652"></a>00652                                 {
<a name="l00653"></a>00653                                         <span class="keywordflow">if</span> (!pNode-&gt;isBC(j))
<a name="l00654"></a>00654                                         {
<a name="l00655"></a>00655                                                 num = num + 1;
<a name="l00656"></a>00656                                                 pNode-&gt;eqnNumber(j) = num;
<a name="l00657"></a>00657                                         }
<a name="l00658"></a>00658                                 }
<a name="l00659"></a>00659                         }
<a name="l00660"></a>00660                         
<a name="l00661"></a>00661                         sysDim = num + 1;          <span class="comment">// set linear system dimension</span>
<a name="l00662"></a>00662                         
<a name="l00663"></a>00663                         <span class="comment">//std::cout&lt;&lt; &quot;number of dof = &quot; &lt;&lt; sysDim &lt;&lt; std::endl;</span>
<a name="l00664"></a>00664                         
<a name="l00665"></a>00665                         <span class="comment">/*for (int i = 0 ; i &lt; nodeContainer.size(); i++ )</span>
<a name="l00666"></a>00666 <span class="comment">                         {      </span>
<a name="l00667"></a>00667 <span class="comment">                         pNode = nodeContainer[i];</span>
<a name="l00668"></a>00668 <span class="comment">                         std::cout&lt;&lt; &quot;Node=   &quot;&lt;&lt; pNode-&gt;sID &lt;&lt; &quot;:  &quot; &lt;&lt; pNode-&gt;u.isBC[0] &lt;&lt; &quot;  &quot; &lt;&lt; pNode-&gt;u.isBC[1] &lt;&lt; &quot;  &quot;&lt;&lt; pNode-&gt;u.isBC[2] &lt;&lt; &quot;  &quot;&lt;&lt; pNode-&gt;u.eqnNumber[0] &lt;&lt; &quot;  &quot; &lt;&lt; pNode-&gt;u.eqnNumber[1] &lt;&lt; &quot;  &quot;&lt;&lt; pNode-&gt;u.eqnNumber[2] &lt;&lt; &quot;  &quot;&lt;&lt; std::endl;</span>
<a name="l00669"></a>00669 <span class="comment">                         }*/</span>
<a name="l00670"></a>00670                         
<a name="l00671"></a>00671                         
<a name="l00672"></a>00672                 }
<a name="l00673"></a>00673                 
<a name="l00674"></a>00674                 <span class="comment">//===================================================================================</span>
<a name="l00675"></a>00675                 <span class="comment">// function to assemble the global stiffness matrix</span>
<a name="l00676"></a>00676                 <span class="comment">//===================================================================================</span>
<a name="l00677"></a>00677                 
<a name="l00678"></a>00678                 <span class="keywordtype">void</span> assemble (Eigen::SparseMatrix&lt;double&gt; &amp; Km, Eigen::VectorXd&amp; Fm)
<a name="l00679"></a>00679                 {
<a name="l00680"></a>00680                         <span class="comment">//bvpfe::Tetrahedron* pTet;</span>
<a name="l00681"></a>00681                         <span class="comment">//std::vector&lt;Vector&gt; tetMat;         // 12x12 stiffness matrix for each tetrahedron</span>
<a name="l00682"></a>00682                         Eigen::Matrix&lt;double,12,12&gt; tetMat;         <span class="comment">// 12x12 stiffness matrix for each tetrahedron</span>
<a name="l00683"></a>00683                         
<a name="l00684"></a>00684                         <span class="comment">//std::vector&lt;Vector&gt; Np;             // shape functions derivatives mapped to actual element</span>
<a name="l00685"></a>00685                         Eigen::Matrix&lt;double,dim,Tetrahedron::Nnodes&gt; Np;   <span class="comment">// shape functions derivatives mapped to actual element</span>
<a name="l00686"></a>00686                         
<a name="l00687"></a>00687                         <span class="keywordtype">int</span> qi, qj;
<a name="l00688"></a>00688                         <span class="keywordtype">int</span> ie , je;
<a name="l00689"></a>00689                         
<a name="l00690"></a>00690                         <span class="keywordtype">double</span> wv;
<a name="l00691"></a>00691                         
<a name="l00692"></a>00692                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;tetContainer.size() ; i++) {
<a name="l00693"></a>00693                                 
<a name="l00694"></a>00694                                 <span class="comment">//pTet = &amp;tetContainer[i];</span>
<a name="l00695"></a>00695                                 
<a name="l00696"></a>00696                                 tetMat = tetContainer[i].getElementStiffness(Np, wv);
<a name="l00697"></a>00697                                 
<a name="l00698"></a>00698                                 <span class="comment">//---------- assemble tetMat to the global matrix ---------------------------</span>
<a name="l00699"></a>00699                                 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ai = 0 ; ai &lt; 4 ; ai ++)            <span class="comment">// no. of nodes per Tet</span>
<a name="l00700"></a>00700                                 {
<a name="l00701"></a>00701                                         ie= ai*3;
<a name="l00702"></a>00702                                         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> in = 0 ; in &lt; 3 ; in ++)    <span class="comment">//no. of DOFs per node</span>
<a name="l00703"></a>00703                                         {
<a name="l00704"></a>00704                                                 qi = tetContainer[i].eleNodes[ai]-&gt;eqnNumber[in];
<a name="l00705"></a>00705                                                 <span class="keywordflow">if</span> (qi == -1) <span class="keywordflow">continue</span>;
<a name="l00706"></a>00706                                                 
<a name="l00707"></a>00707                                                 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bi = 0 ; bi &lt; 4 ; bi ++)
<a name="l00708"></a>00708                                                 {
<a name="l00709"></a>00709                                                         je = bi*3 ; 
<a name="l00710"></a>00710                                                         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jn = 0 ; jn &lt; 3 ; jn ++)
<a name="l00711"></a>00711                                                         {
<a name="l00712"></a>00712                                                                 qj = tetContainer[i].eleNodes[bi]-&gt;eqnNumber(jn);
<a name="l00713"></a>00713                                                                 <span class="keywordflow">if</span> (qj == -1)
<a name="l00714"></a>00714                                                                 {
<a name="l00715"></a>00715                                                                         Fm(qi)=Fm(qi)-(tetMat(ie+in,je+jn)*tetContainer[i].eleNodes[bi]-&gt;bcValue[jn]);
<a name="l00716"></a>00716                                                                         <span class="comment">//std::cout&lt;&lt; &quot;out111=== &quot; &lt;&lt; tetMat(ie+in,je+jn) &lt;&lt; &quot;  &quot; &lt;&lt; tetContainer[i].eleNodes[bi]-&gt;u.bcValue[jn] &lt;&lt; std::endl;</span>
<a name="l00717"></a>00717                                                                         <span class="keywordflow">continue</span>;
<a name="l00718"></a>00718                                                                 }
<a name="l00719"></a>00719                                                                 
<a name="l00720"></a>00720                                                                 <span class="comment">//Km.set(qi,qj) = Km(qi,qj) + (tetMat(ie+in,je+jn));</span>
<a name="l00721"></a>00721                                                                 Km.coeffRef(qi,qj) += tetMat(ie+in,je+jn);
<a name="l00722"></a>00722                                                         }
<a name="l00723"></a>00723                                                 }
<a name="l00724"></a>00724                                         }
<a name="l00725"></a>00725                                 }
<a name="l00726"></a>00726                                 
<a name="l00727"></a>00727                                 
<a name="l00728"></a>00728                                 <span class="comment">//------------- assemble the dislocation force vector, if required ----------</span>
<a name="l00729"></a>00729                                 
<a name="l00730"></a>00730                                 <span class="comment">/*if(disStress)</span>
<a name="l00731"></a>00731 <span class="comment">                                 {</span>
<a name="l00732"></a>00732 <span class="comment">                                 </span>
<a name="l00733"></a>00733 <span class="comment">                                 Eigen::Matrix&lt;double,dim,Tetrahedron::Nnodes&gt; temp=tetContainer[i].get_dislocationForceVector&lt;4,T&gt;(pT,Np);</span>
<a name="l00734"></a>00734 <span class="comment">                                 </span>
<a name="l00735"></a>00735 <span class="comment">                                 </span>
<a name="l00736"></a>00736 <span class="comment">                                 //----------- assemble in the global force vector ------------------</span>
<a name="l00737"></a>00737 <span class="comment">                                 for ( unsigned int in = 0 ; in &lt; Tetrahedron::Nnodes ; in ++)            // no. of nodes per Tet</span>
<a name="l00738"></a>00738 <span class="comment">                                 {                                              </span>
<a name="l00739"></a>00739 <span class="comment">                                 for ( unsigned int id = 0 ; id &lt; dim ; id ++)    //no. of DOFs per node</span>
<a name="l00740"></a>00740 <span class="comment">                                 {</span>
<a name="l00741"></a>00741 <span class="comment">                                 qi = tetContainer[i].eleNodes[in]-&gt;u.eqnNumber[id];</span>
<a name="l00742"></a>00742 <span class="comment">                                 if (qi == -1) continue;</span>
<a name="l00743"></a>00743 <span class="comment">                                 </span>
<a name="l00744"></a>00744 <span class="comment">                                 Fm(qi)=Fm(qi)-temp(id,in);</span>
<a name="l00745"></a>00745 <span class="comment">                                 </span>
<a name="l00746"></a>00746 <span class="comment">                                 }</span>
<a name="l00747"></a>00747 <span class="comment">                                 }</span>
<a name="l00748"></a>00748 <span class="comment">                                 }*/</span>
<a name="l00749"></a>00749                                 
<a name="l00750"></a>00750                         }
<a name="l00751"></a>00751                 }
<a name="l00752"></a>00752                 
<a name="l00753"></a>00753                 
<a name="l00754"></a>00754                 <span class="comment">//===================================================================================</span>
<a name="l00755"></a>00755                 <span class="comment">// function to initiate the sparse linear system</span>
<a name="l00756"></a>00756                 <span class="comment">//===================================================================================</span>
<a name="l00757"></a>00757                 
<a name="l00758"></a>00758                 <span class="keywordtype">void</span> initiateSparseSystem(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; nz, std::vector&lt;int&gt;&amp; rr, std::vector&lt;int&gt;&amp; cc )
<a name="l00759"></a>00759                 {
<a name="l00760"></a>00760                         <span class="keywordtype">int</span> qi, qj;
<a name="l00761"></a>00761                         
<a name="l00762"></a>00762                         <a class="code" href="classbvpfe_1_1_node.html">Node&lt;dim&gt;</a>* pNodei;
<a name="l00763"></a>00763                         <a class="code" href="classbvpfe_1_1_node.html">Node&lt;dim&gt;</a>* pNodej;
<a name="l00764"></a>00764                         
<a name="l00765"></a>00765                         <span class="comment">// ---- sort the neighbor vector for each node. This makes it easy to initiate sparse system ---</span>
<a name="l00766"></a>00766                         
<a name="l00767"></a>00767                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nodeContainer.size() ; i++) {
<a name="l00768"></a>00768                                 nodeContainer[i].sortNeighbors();
<a name="l00769"></a>00769                                 <span class="comment">//                              pNodei = &amp;nodeContainer[i];</span>
<a name="l00770"></a>00770                                 <span class="comment">//                              pNodei-&gt;sortNeighbors();</span>
<a name="l00771"></a>00771                                 
<a name="l00772"></a>00772                                 <span class="comment">/*std::cout&lt;&lt; pNodei-&gt;sID&lt;&lt; &quot; : &quot; ;</span>
<a name="l00773"></a>00773 <span class="comment">                                 for (int j=0; j&lt;pNodei-&gt;neighbor.size() ; j++)</span>
<a name="l00774"></a>00774 <span class="comment">                                 {</span>
<a name="l00775"></a>00775 <span class="comment">                                 std::cout&lt;&lt; pNodei-&gt;neighbor[j]-&gt;sID&lt;&lt; &quot;  &quot; ;</span>
<a name="l00776"></a>00776 <span class="comment">                                 }</span>
<a name="l00777"></a>00777 <span class="comment">                                 std::cout&lt;&lt; std::endl;*/</span>
<a name="l00778"></a>00778                         }
<a name="l00779"></a>00779                         
<a name="l00780"></a>00780                         <span class="comment">//---- loop over all nodes to get the positions of nonzero elements------</span>
<a name="l00781"></a>00781                         
<a name="l00782"></a>00782                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nodeContainer.size() ; i++) {
<a name="l00783"></a>00783                                 
<a name="l00784"></a>00784                                 pNodei = &amp;nodeContainer[i];
<a name="l00785"></a>00785                                 
<a name="l00786"></a>00786                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0; ii&lt;dim; ii++)
<a name="l00787"></a>00787                                 {
<a name="l00788"></a>00788                                         qi = pNodei-&gt;eqnNumber(ii);
<a name="l00789"></a>00789                                         <span class="keywordflow">if</span> (qi == -1) <span class="keywordflow">continue</span>;
<a name="l00790"></a>00790                                         
<a name="l00791"></a>00791                                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j&lt;pNodei-&gt;neighbor.size(); j++)
<a name="l00792"></a>00792                                         {
<a name="l00793"></a>00793                                                 pNodej = pNodei-&gt;neighbor[j];
<a name="l00794"></a>00794                                                 
<a name="l00795"></a>00795                                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jj = 0; jj&lt;dim; jj++)
<a name="l00796"></a>00796                                                 {
<a name="l00797"></a>00797                                                         qj = pNodej-&gt;eqnNumber(jj);
<a name="l00798"></a>00798                                                         <span class="keywordflow">if</span> (qj == -1) <span class="keywordflow">continue</span>;
<a name="l00799"></a>00799                                                         
<a name="l00800"></a>00800                                                         rr.push_back(qi);     cc.push_back(qj);
<a name="l00801"></a>00801                                                 }
<a name="l00802"></a>00802                                         }
<a name="l00803"></a>00803                                 }
<a name="l00804"></a>00804                                 
<a name="l00805"></a>00805                         }
<a name="l00806"></a>00806                         
<a name="l00807"></a>00807                         nz = rr.size();
<a name="l00808"></a>00808                         
<a name="l00809"></a>00809                         <span class="comment">//std::cout &lt;&lt; &quot;nz = &quot; &lt;&lt; nz &lt;&lt; std::endl;</span>
<a name="l00810"></a>00810                         
<a name="l00811"></a>00811                         <span class="comment">/*for (int i = 0; i&lt;rr.size() ; i++)</span>
<a name="l00812"></a>00812 <span class="comment">                         {</span>
<a name="l00813"></a>00813 <span class="comment">                         std::cout &lt;&lt; rr[i] &lt;&lt; &quot;  &quot;&lt;&lt; cc[i] &lt;&lt; std::endl;</span>
<a name="l00814"></a>00814 <span class="comment">                         }*/</span>    
<a name="l00815"></a>00815                         
<a name="l00816"></a>00816                         
<a name="l00817"></a>00817                 }
<a name="l00818"></a>00818                 
<a name="l00819"></a>00819                 <span class="comment">//===================================================================================</span>
<a name="l00820"></a>00820                 <span class="comment">// function to assemble the force vector from infinite medium surface traction</span>
<a name="l00821"></a>00821                 <span class="comment">//===================================================================================</span>
<a name="l00822"></a>00822                 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00823"></a>00823                 <span class="keywordtype">void</span> assembleInfiniteTraction (Eigen::VectorXd&amp; Fm , <span class="keyword">const</span> T* <span class="keyword">const</span> pT) {
<a name="l00824"></a>00824                         
<a name="l00825"></a>00825                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0 ; i&lt; Finf.size() ; i++ )  Finf[i]= 0.0;
<a name="l00826"></a>00826                         
<a name="l00827"></a>00827                         Eigen::Matrix&lt;double,dim,3&gt; TriVec;       <span class="comment">// 3 is the number of nodes per triangle</span>
<a name="l00828"></a>00828                         
<a name="l00829"></a>00829                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nID;
<a name="l00830"></a>00830                         <a class="code" href="classbvpfe_1_1_triangle.html">Triangle</a>* pTri;
<a name="l00831"></a>00831                         std::vector&lt;Triangle*&gt;::iterator itt;
<a name="l00832"></a>00832                         
<a name="l00833"></a>00833                         <span class="keywordflow">for</span> (itt= triContainer.begin() ; itt != triContainer.end(); itt++ ) {
<a name="l00834"></a>00834                                 
<a name="l00835"></a>00835                                 pTri = *itt; 
<a name="l00836"></a>00836                                 
<a name="l00837"></a>00837                                 <span class="comment">//TriVec = pTri-&gt;getTriInfiniteForce&lt;3,T&gt;(pT);</span>
<a name="l00838"></a>00838                                 TriVec = pTri-&gt;getTriInfiniteForce_gp&lt;T&gt;(pT);
<a name="l00839"></a>00839                                 
<a name="l00840"></a>00840                                 
<a name="l00841"></a>00841                                 <span class="comment">//------------- assemble the infinite traction vector --------------</span>
<a name="l00842"></a>00842                                 <span class="keywordtype">int</span>  qi;
<a name="l00843"></a>00843                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ai = 0 ; ai &lt; 3; ai++ )             <span class="comment">// loop over the 3 surface element&#39;s nodes</span>
<a name="l00844"></a>00844                                 {
<a name="l00845"></a>00845                                         nID = pTri-&gt;eleNodes[ai]-&gt;sID;        <span class="comment">// node global index</span>
<a name="l00846"></a>00846                                         
<a name="l00847"></a>00847                                         <span class="keywordflow">for</span>  (<span class="keywordtype">int</span> in = 0 ; in &lt; 3; in++ )   <span class="comment">// loop over the 3 dofs</span>
<a name="l00848"></a>00848                                         {
<a name="l00849"></a>00849                                                 Finf[(nID*3)+in] = Finf[(nID*3)+in] + TriVec(in,ai);  <span class="comment">// -ve sigen for the infinite field is considered in Triangle::dislocationStressKernel</span>
<a name="l00850"></a>00850                                                 
<a name="l00851"></a>00851                                                 qi = pTri-&gt;eleNodes[ai]-&gt;eqnNumber(in);
<a name="l00852"></a>00852                                                 <span class="keywordflow">if</span> (qi != -1) Fm(qi) = Fm(qi) + TriVec(in,ai);  <span class="comment">// -ve sigen for the infinite field is considered in Triangle::dislocationStressKernel</span>
<a name="l00853"></a>00853                                         }
<a name="l00854"></a>00854                                 }
<a name="l00855"></a>00855                                 
<a name="l00856"></a>00856                         }
<a name="l00857"></a>00857                         
<a name="l00858"></a>00858                         <span class="comment">//--------------- Assemble the infinte medium traction vector for the remaining triangles, which have some dislocations cutting them ----</span>
<a name="l00859"></a>00859                         
<a name="l00860"></a>00860                         <span class="comment">//std::set&lt;unsigned int&gt; trisSet;</span>
<a name="l00861"></a>00861                         <span class="comment">//trisSet = pT-&gt;fillTrianglesSet();</span>
<a name="l00862"></a>00862                         <span class="comment">/*for (std::set&lt;unsigned int&gt;::iterator it =cutTrisSet.begin(); it != cutTrisSet.end(); it++ ) {</span>
<a name="l00863"></a>00863 <span class="comment">                          std::cout&lt;&lt; *it &lt;&lt; &quot;  &quot;;</span>
<a name="l00864"></a>00864 <span class="comment">                        }</span>
<a name="l00865"></a>00865 <span class="comment">                        std::cout&lt;&lt;std::endl;</span>
<a name="l00866"></a>00866 <span class="comment">                        */</span>
<a name="l00867"></a>00867                         
<a name="l00868"></a>00868                         <span class="comment">//FILE *ft =fopen(&quot;triangles.txt&quot;, &quot;w&quot;);</span>
<a name="l00869"></a>00869                         <span class="comment">/*</span>
<a name="l00870"></a>00870 <span class="comment">                        for (std::set&lt;unsigned int&gt;::iterator it =cutTrisSet.begin(); it != cutTrisSet.end(); it++ ) {</span>
<a name="l00871"></a>00871 <span class="comment">                          //std::cout&lt;&lt; &quot;TriID:  &quot; &lt;&lt; *it &lt;&lt; std::endl;</span>
<a name="l00872"></a>00872 <span class="comment">                          pTri =  triContainer[*it];</span>
<a name="l00873"></a>00873 <span class="comment">                          //for (unsigned int i=0; i&lt;pTri-&gt;cuttingSegments.size(); i++) std::cout&lt;&lt; pT-&gt;link(pTri-&gt;cuttingSegments[i].first,pTri-&gt;cuttingSegments[i].second).second-&gt;chordLength()&lt;&lt; std::endl;</span>
<a name="l00874"></a>00874 <span class="comment">                          </span>
<a name="l00875"></a>00875 <span class="comment">                          for (unsigned int iSeg=0; iSeg &lt; pTri-&gt;cuttingSegments.size(); iSeg++) {</span>
<a name="l00876"></a>00876 <span class="comment">                            assert (pT-&gt;link(pTri-&gt;cuttingSegments[iSeg].first,pTri-&gt;cuttingSegments[iSeg].second).second-&gt;pGlidePlane-&gt;segmentMeshCollisionPairContainer.find(*it) !=</span>
<a name="l00877"></a>00877 <span class="comment">                                    pT-&gt;link(pTri-&gt;cuttingSegments[iSeg].first,pTri-&gt;cuttingSegments[iSeg].second).second-&gt;pGlidePlane-&gt;segmentMeshCollisionPairContainer.end()     &amp;&amp; </span>
<a name="l00878"></a>00878 <span class="comment">                                    &quot;Error in assembleInfiniteTraction function: Target triangle is NOT in the segment&#39;s glide plane list &quot;);</span>
<a name="l00879"></a>00879 <span class="comment">                                    </span>
<a name="l00880"></a>00880 <span class="comment">                            // --- splite the triangle into subtriangles, given the intersection line between the segment&#39;s glide plane and the triangle</span>
<a name="l00881"></a>00881 <span class="comment">                            std::vector&lt;Eigen::Matrix&lt;double,dim,dim&gt; &gt; trisPoints = pTri-&gt;spliteTriangle (pT-&gt;link(pTri-&gt;cuttingSegments[iSeg].first,pTri-&gt;cuttingSegments[iSeg].second).second-&gt;pGlidePlane-&gt;segmentMeshCollisionPairContainer.find(*it)-&gt;second);</span>
<a name="l00882"></a>00882 <span class="comment">                            </span>
<a name="l00883"></a>00883 <span class="comment">                            </span>
<a name="l00884"></a>00884 <span class="comment">                            </span>
<a name="l00885"></a>00885 <span class="comment">                            //----------- loop over all subtriangles and integrate (Sigma_inf*shape_function)</span>
<a name="l00886"></a>00886 <span class="comment">                            for (unsigned int iST=0; iST&lt;trisPoints.size(); iST++) {</span>
<a name="l00887"></a>00887 <span class="comment">                              Eigen::Matrix&lt;double,3,3&gt; tp = trisPoints[iST];</span>
<a name="l00888"></a>00888 <span class="comment">                              //fprintf (ft, &quot;%22.15e %22.15e %22.15e %22.15e %22.15e %22.15e %22.15e %22.15e %22.15e \n&quot;,tp(0,0),tp(0,1),tp(0,2),tp(1,0),tp(1,1),tp(1,2),tp(2,0),tp(2,1),tp(2,2));</span>
<a name="l00889"></a>00889 <span class="comment">                              TriVec = pTri-&gt;subTri_getTriInfiniteForce&lt;3,T&gt;(pT,trisPoints[iST],iSeg);</span>
<a name="l00890"></a>00890 <span class="comment">                              </span>
<a name="l00891"></a>00891 <span class="comment">                              //------------- assemble the infinite traction vector --------------</span>
<a name="l00892"></a>00892 <span class="comment">                              int  qi;</span>
<a name="l00893"></a>00893 <span class="comment">                              for (int ai = 0 ; ai &lt; 3; ai++ )             // loop over the 3 surface element&#39;s nodes</span>
<a name="l00894"></a>00894 <span class="comment">                              {</span>
<a name="l00895"></a>00895 <span class="comment">                                nID = pTri-&gt;eleNodes[ai]-&gt;sID;        // node global index</span>
<a name="l00896"></a>00896 <span class="comment">                                </span>
<a name="l00897"></a>00897 <span class="comment">                                for  (int in = 0 ; in &lt; 3; in++ )   // loop over the 3 dofs</span>
<a name="l00898"></a>00898 <span class="comment">                                {</span>
<a name="l00899"></a>00899 <span class="comment">                                  Finf[(nID*3)+in] = Finf[(nID*3)+in] + TriVec(in,ai);  // -ve sigen for the infinite field is considered in Triangle::dislocationStressKernel</span>
<a name="l00900"></a>00900 <span class="comment">                                  </span>
<a name="l00901"></a>00901 <span class="comment">                                  qi = pTri-&gt;eleNodes[ai]-&gt;eqnNumber(in);</span>
<a name="l00902"></a>00902 <span class="comment">                                  if (qi != -1) Fm(qi) = Fm(qi) + TriVec(in,ai);  // -ve sigen for the infinite field is considered in Triangle::dislocationStressKernel</span>
<a name="l00903"></a>00903 <span class="comment">                                }</span>
<a name="l00904"></a>00904 <span class="comment">                              }</span>
<a name="l00905"></a>00905 <span class="comment">                            }</span>
<a name="l00906"></a>00906 <span class="comment">                            </span>
<a name="l00907"></a>00907 <span class="comment">                            </span>
<a name="l00908"></a>00908 <span class="comment">                            </span>
<a name="l00909"></a>00909 <span class="comment">                          } </span>
<a name="l00910"></a>00910 <span class="comment">                          </span>
<a name="l00911"></a>00911 <span class="comment">                        }</span>
<a name="l00912"></a>00912 <span class="comment">                        */</span>
<a name="l00913"></a>00913                         <span class="comment">//fclose(ft);</span>
<a name="l00914"></a>00914                         
<a name="l00915"></a>00915                         <span class="comment">/*</span>
<a name="l00916"></a>00916 <span class="comment">                        </span>
<a name="l00917"></a>00917 <span class="comment">                        for (std::set&lt;unsigned int&gt;::iterator it =cutTrisSet.begin(); it != cutTrisSet.end(); it++ ) {</span>
<a name="l00918"></a>00918 <span class="comment">                          //std::cout&lt;&lt; &quot;TriID:  &quot; &lt;&lt; *it &lt;&lt; std::endl;</span>
<a name="l00919"></a>00919 <span class="comment">                          pTri =  triContainer[*it];</span>
<a name="l00920"></a>00920 <span class="comment">                          //for (unsigned int i=0; i&lt;pTri-&gt;cuttingSegments.size(); i++) std::cout&lt;&lt; pT-&gt;link(pTri-&gt;cuttingSegments[i].first,pTri-&gt;cuttingSegments[i].second).second-&gt;chordLength()&lt;&lt; std::endl;</span>
<a name="l00921"></a>00921 <span class="comment">                          </span>
<a name="l00922"></a>00922 <span class="comment">                          for (unsigned int iSeg=0; iSeg &lt; pTri-&gt;cuttingSegments.size(); iSeg++) {</span>
<a name="l00923"></a>00923 <span class="comment">                            </span>
<a name="l00924"></a>00924 <span class="comment">                              TriVec = pTri-&gt;getTriInfiniteForce_Seg&lt;T&gt;(pT,iSeg);</span>
<a name="l00925"></a>00925 <span class="comment">                              </span>
<a name="l00926"></a>00926 <span class="comment">                              //------------- assemble the infinite traction vector --------------</span>
<a name="l00927"></a>00927 <span class="comment">                              int  qi;</span>
<a name="l00928"></a>00928 <span class="comment">                              for (int ai = 0 ; ai &lt; 3; ai++ )             // loop over the 3 surface element&#39;s nodes</span>
<a name="l00929"></a>00929 <span class="comment">                              {</span>
<a name="l00930"></a>00930 <span class="comment">                                nID = pTri-&gt;eleNodes[ai]-&gt;sID;        // node global index</span>
<a name="l00931"></a>00931 <span class="comment">                                </span>
<a name="l00932"></a>00932 <span class="comment">                                for  (int in = 0 ; in &lt; 3; in++ )   // loop over the 3 dofs</span>
<a name="l00933"></a>00933 <span class="comment">                                {</span>
<a name="l00934"></a>00934 <span class="comment">                                  Finf[(nID*3)+in] = Finf[(nID*3)+in] + TriVec(in,ai);  // -ve sigen for the infinite field is considered in Triangle::dislocationStressKernel</span>
<a name="l00935"></a>00935 <span class="comment">                                  </span>
<a name="l00936"></a>00936 <span class="comment">                                  qi = pTri-&gt;eleNodes[ai]-&gt;eqnNumber(in);</span>
<a name="l00937"></a>00937 <span class="comment">                                  if (qi != -1) Fm(qi) = Fm(qi) + TriVec(in,ai);  // -ve sigen for the infinite field is considered in Triangle::dislocationStressKernel</span>
<a name="l00938"></a>00938 <span class="comment">                                }</span>
<a name="l00939"></a>00939 <span class="comment">                              }</span>
<a name="l00940"></a>00940 <span class="comment">                            </span>
<a name="l00941"></a>00941 <span class="comment">                            </span>
<a name="l00942"></a>00942 <span class="comment">                          } </span>
<a name="l00943"></a>00943 <span class="comment">                          </span>
<a name="l00944"></a>00944 <span class="comment">                        }</span>
<a name="l00945"></a>00945 <span class="comment">                        */</span>
<a name="l00946"></a>00946                         
<a name="l00947"></a>00947                 }
<a name="l00948"></a>00948                 
<a name="l00949"></a>00949                 <span class="comment">//===================================================================================</span>
<a name="l00950"></a>00950                 <span class="comment">// function to assemble the force vector from surface traction</span>
<a name="l00951"></a>00951                 <span class="comment">// we assume here uniform traction over the surface, so one quadrature point is used</span>
<a name="l00952"></a>00952                 <span class="comment">//===================================================================================</span>
<a name="l00953"></a>00953                 <span class="comment">/*</span>
<a name="l00954"></a>00954 <span class="comment">                 void assembleTractionForce (VECTOR_double&amp; Fm )</span>
<a name="l00955"></a>00955 <span class="comment">                 {</span>
<a name="l00956"></a>00956 <span class="comment">                 bvpfe::Face* pFace;</span>
<a name="l00957"></a>00957 <span class="comment">                 std::map&lt;bvpfe::Face*,std::vector&lt;double&gt; &gt;::iterator itf;</span>
<a name="l00958"></a>00958 <span class="comment">                 std::vector&lt;double&gt; tr;</span>
<a name="l00959"></a>00959 <span class="comment">                 </span>
<a name="l00960"></a>00960 <span class="comment">                 bvpfe::Triangle* pTri;</span>
<a name="l00961"></a>00961 <span class="comment">                 std::map&lt;size_t,bvpfe::Triangle*&gt;::iterator itt;</span>
<a name="l00962"></a>00962 <span class="comment">                 </span>
<a name="l00963"></a>00963 <span class="comment">                 std::vector&lt;double&gt; triVec;</span>
<a name="l00964"></a>00964 <span class="comment">                 triVec.resize(9,0.0e+00);     //The force vector for each triangle</span>
<a name="l00965"></a>00965 <span class="comment">                 </span>
<a name="l00966"></a>00966 <span class="comment">                 int ie , qi;</span>
<a name="l00967"></a>00967 <span class="comment">                 </span>
<a name="l00968"></a>00968 <span class="comment">                 //--------- loop over all faces subjected to traction ----------</span>
<a name="l00969"></a>00969 <span class="comment">                 for (itf= facesWtraction.begin() ; itf != facesWtraction.end(); itf++ )</span>
<a name="l00970"></a>00970 <span class="comment">                 {</span>
<a name="l00971"></a>00971 <span class="comment">                 pFace = itf-&gt;first;</span>
<a name="l00972"></a>00972 <span class="comment">                 tr = itf-&gt;second;</span>
<a name="l00973"></a>00973 <span class="comment">                 </span>
<a name="l00974"></a>00974 <span class="comment">                 //std::cout&lt;&lt; &quot;traction &quot; &lt;&lt; tr[0] &lt;&lt; &quot; &quot; &lt;&lt; tr[1] &lt;&lt; &quot; &quot; &lt;&lt; tr[2] &lt;&lt; std::endl;</span>
<a name="l00975"></a>00975 <span class="comment">                 </span>
<a name="l00976"></a>00976 <span class="comment">                 // ---------- loop over all triangles of the face ------------</span>
<a name="l00977"></a>00977 <span class="comment">                 for (itt= pFace-&gt;triContainer.begin() ; itt != pFace-&gt;triContainer.end(); itt++ )</span>
<a name="l00978"></a>00978 <span class="comment">                 {</span>
<a name="l00979"></a>00979 <span class="comment">                 pTri = itt-&gt;second;</span>
<a name="l00980"></a>00980 <span class="comment">                 </span>
<a name="l00981"></a>00981 <span class="comment">                 triVec = pTri-&gt;getForceVec(tr);</span>
<a name="l00982"></a>00982 <span class="comment">                 </span>
<a name="l00983"></a>00983 <span class="comment">                 for (int ai = 0 ; ai &lt; 3; ai++ )             // loop over the 3 surface element&#39;s nodes</span>
<a name="l00984"></a>00984 <span class="comment">                 {</span>
<a name="l00985"></a>00985 <span class="comment">                 ie = ai*3;</span>
<a name="l00986"></a>00986 <span class="comment">                 </span>
<a name="l00987"></a>00987 <span class="comment">                 for  (int in = 0 ; in &lt; 3; in++ )   // loop over the 3 dofs</span>
<a name="l00988"></a>00988 <span class="comment">                 {</span>
<a name="l00989"></a>00989 <span class="comment">                 qi = pTri-&gt;eleNodes[ai]-&gt;eqnNumber(in);</span>
<a name="l00990"></a>00990 <span class="comment">                 if (qi == -1) continue;</span>
<a name="l00991"></a>00991 <span class="comment">                 Fm(qi) = Fm(qi) +  triVec[ie+in]; </span>
<a name="l00992"></a>00992 <span class="comment">                 }</span>
<a name="l00993"></a>00993 <span class="comment">                 }</span>
<a name="l00994"></a>00994 <span class="comment">                 }</span>
<a name="l00995"></a>00995 <span class="comment">                 }</span>
<a name="l00996"></a>00996 <span class="comment">                 </span>
<a name="l00997"></a>00997 <span class="comment">                 </span>
<a name="l00998"></a>00998 <span class="comment">                 }</span>
<a name="l00999"></a>00999 <span class="comment">                 */</span>
<a name="l01000"></a>01000                 <span class="comment">//===================================================================================</span>
<a name="l01001"></a>01001                 <span class="comment">// function to calculate the stress field at any given point</span>
<a name="l01002"></a>01002                 <span class="comment">//==================================================================================</span>
<a name="l01003"></a>01003                 Eigen::Matrix&lt;double,dim,dim&gt; stressAt(<span class="keyword">const</span> VectorDim&amp; P)
<a name="l01004"></a>01004                 {
<a name="l01005"></a>01005                         Eigen::Matrix&lt;double,dim,dim&gt; stress = Eigen::Matrix&lt;double,dim,dim&gt;::Zero(); 
<a name="l01006"></a>01006                         isTetrahedronType isT = findIncludingTet(P);
<a name="l01007"></a>01007                         
<a name="l01008"></a>01008                         <span class="comment">/*std::cout &lt;&lt; &quot;tetrahedron number : &quot; &lt;&lt; pTet-&gt;sID&lt;&lt; std::endl;</span>
<a name="l01009"></a>01009 <span class="comment">                         std::cout&lt;&lt; &quot;Point: &quot;&lt;&lt; P[0]&lt;&lt; &quot; &quot;&lt;&lt; P[1]&lt;&lt; &quot; &quot;&lt;&lt; P[2]&lt;&lt; &quot; &quot;&lt;&lt;std::endl;</span>
<a name="l01010"></a>01010 <span class="comment">                         </span>
<a name="l01011"></a>01011 <span class="comment">                         std::cout&lt;&lt; pTet-&gt;eleNodes[0]-&gt;P[0]&lt;&lt; &quot; &quot;&lt;&lt; pTet-&gt;eleNodes[0]-&gt;P[1]&lt;&lt; &quot; &quot;&lt;&lt; pTet-&gt;eleNodes[0]-&gt;P[2]&lt;&lt; &quot; &quot;&lt;&lt;std::endl; </span>
<a name="l01012"></a>01012 <span class="comment">                         std::cout&lt;&lt; pTet-&gt;eleNodes[1]-&gt;P[0]&lt;&lt; &quot; &quot;&lt;&lt; pTet-&gt;eleNodes[1]-&gt;P[1]&lt;&lt; &quot; &quot;&lt;&lt; pTet-&gt;eleNodes[1]-&gt;P[2]&lt;&lt; &quot; &quot;&lt;&lt;std::endl; </span>
<a name="l01013"></a>01013 <span class="comment">                         std::cout&lt;&lt; pTet-&gt;eleNodes[2]-&gt;P[0]&lt;&lt; &quot; &quot;&lt;&lt; pTet-&gt;eleNodes[2]-&gt;P[1]&lt;&lt; &quot; &quot;&lt;&lt; pTet-&gt;eleNodes[2]-&gt;P[2]&lt;&lt; &quot; &quot;&lt;&lt;std::endl; </span>
<a name="l01014"></a>01014 <span class="comment">                         std::cout&lt;&lt; pTet-&gt;eleNodes[3]-&gt;P[0]&lt;&lt; &quot; &quot;&lt;&lt; pTet-&gt;eleNodes[3]-&gt;P[1]&lt;&lt; &quot; &quot;&lt;&lt; pTet-&gt;eleNodes[3]-&gt;P[2]&lt;&lt; &quot; &quot;&lt;&lt;std::endl; */</span>
<a name="l01015"></a>01015                         
<a name="l01016"></a>01016                         <span class="keywordflow">if</span> (isT.first) {stress = isT.second-&gt;getStress();}
<a name="l01017"></a>01017                         
<a name="l01018"></a>01018                         <span class="keywordflow">return</span> stress;
<a name="l01019"></a>01019                 }
<a name="l01020"></a>01020                 
<a name="l01021"></a>01021                 <span class="comment">//===================================================================================</span>
<a name="l01022"></a>01022                 <span class="comment">// function to search for the including tetrahedron given the new position for the point, </span>
<a name="l01023"></a>01023                 <span class="comment">// old point&#39;s tetrahedron index, and search direction vector</span>
<a name="l01024"></a>01024                 <span class="comment">//===================================================================================</span>
<a name="l01025"></a>01025                 
<a name="l01026"></a>01026                 <span class="keywordtype">void</span> SearchMovingNode (<a class="code" href="structmmdl_1_1_search_data.html">mmdl::SearchData&lt;dim&gt;</a> &amp; data){
<a name="l01027"></a>01027                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nn ;
<a name="l01028"></a>01028                         <span class="comment">// --------------NOT boundary node (coming from inside or outside) -----------------------</span>
<a name="l01029"></a>01029                         <span class="keywordflow">if</span>(data.nodeMeshLocation != 2) { 
<a name="l01030"></a>01030                                 
<a name="l01031"></a>01031                                 data.newMeshID = data.currentMeshID;        <span class="comment">// initialize</span>
<a name="l01032"></a>01032                                 <span class="keywordtype">int</span> dI, sI;
<a name="l01033"></a>01033                                 sI = 0;  dI = 0;
<a name="l01034"></a>01034                                 Eigen::Matrix&lt;double,4,1&gt;::Index ii;
<a name="l01035"></a>01035                                 <span class="comment">// , jj;</span>
<a name="l01036"></a>01036                                 VectorDim interP;                              <span class="comment">// should save the velocity-surface intersection point</span>
<a name="l01037"></a>01037                                 <a class="code" href="classbvpfe_1_1_triangle.html">Triangle</a>* pTri;
<a name="l01038"></a>01038                                 <a class="code" href="classbvpfe_1_1_tetrahedron.html">Tetrahedron</a>* pTet;
<a name="l01039"></a>01039                                 
<a name="l01040"></a>01040                                 Eigen::Matrix&lt;double,4,1&gt;  Bary;
<a name="l01041"></a>01041                                 
<a name="l01042"></a>01042                                 <span class="keywordflow">while</span> (!data.found){
<a name="l01043"></a>01043                                         <span class="keywordtype">bool</span> insideTet =  tetContainer[data.newMeshID].isInsideTet(data, sI, Bary);
<a name="l01044"></a>01044                                         
<a name="l01045"></a>01045                                         <span class="keywordflow">if</span>(insideTet) <span class="keywordflow">break</span>;
<a name="l01046"></a>01046                                         
<a name="l01047"></a>01047                                         <span class="comment">//--------if node is found outside, find intersection with boundary, and set it as boundary node ----</span>
<a name="l01048"></a>01048                                         <span class="keywordflow">if</span>(data.nodeMeshLocation == 0){
<a name="l01049"></a>01049                                                 pTet = &amp;tetContainer[data.newMeshID];
<a name="l01050"></a>01050                                                 nn = 0;
<a name="l01051"></a>01051                                                 <span class="keywordflow">while</span>(!data.found){
<a name="l01052"></a>01052                                                         
<a name="l01053"></a>01053                                                         <span class="comment">//---- find the vector-surface intersection point ---------</span>
<a name="l01054"></a>01054                                                         data.newMeshID = pTet-&gt;sID;
<a name="l01055"></a>01055                                                         
<a name="l01056"></a>01056                                                         interP = getSurfaceIntersection(pTet-&gt;TetSurfTris.find(sI)-&gt;second-&gt;outNormal,
<a name="l01057"></a>01057                                                                                                                         pTet-&gt;TetSurfTris.find(sI)-&gt;second-&gt;eleNodes[0]-&gt;P, -data.normalizedDir, data.P);
<a name="l01058"></a>01058                                                         
<a name="l01059"></a>01059                                                         <span class="comment">//------ calculate the barycentric coordinates for this intersection point -------</span>
<a name="l01060"></a>01060                                                         Eigen::Matrix&lt;double,4,1&gt; bary = pTet-&gt;getBarycentric(interP);
<a name="l01061"></a>01061                                                         <span class="keywordtype">double</span> baryMin = bary.minCoeff(&amp;ii);
<a name="l01062"></a>01062                                                         <span class="comment">//double baryMin = pTet-&gt;getBarycentric(interP).minCoeff(&amp;ii);</span>
<a name="l01063"></a>01063                                                         
<a name="l01064"></a>01064                                                         <span class="comment">//------ check if the point is inside, or just outside (but too close) the tetrahedron surface --&gt; DONE ---------</span>
<a name="l01065"></a>01065                                                         <span class="comment">//------ if (ii==sI) so the point is on the tetrahedron surface, with small error from calculations --- </span>
<a name="l01066"></a>01066                                                         <span class="comment">//if(ii==sI) std::cout&lt;&lt; &quot;minBary = &quot; &lt;&lt; baryMin &lt;&lt; std::endl;</span>
<a name="l01067"></a>01067                                                         <span class="keywordflow">if</span>( baryMin&gt;=-1.0e-12 &amp;&amp; baryMin&lt;=1.0e-12   <span class="comment">/*||(ii==sI)*/</span>){
<a name="l01068"></a>01068                                                           <span class="keywordflow">if</span>(pTet-&gt;neighbor[ii]==-1){
<a name="l01069"></a>01069                                                             data.found=<span class="keyword">true</span>;
<a name="l01070"></a>01070                                                             data.projectedP = interP;
<a name="l01071"></a>01071                                                             data.outwardFaceNormal= pTet-&gt;TetSurfTris.find(ii)-&gt;second-&gt;outNormal;
<a name="l01072"></a>01072                                                             data.nodeMeshLocation = 2;      <span class="comment">// boundary node</span>
<a name="l01073"></a>01073                                                             data.triIndex = pTet-&gt;TetSurfTris.find(ii)-&gt;second-&gt;sID;
<a name="l01074"></a>01074                                                             <span class="keywordflow">break</span>;
<a name="l01075"></a>01075                                                           }
<a name="l01076"></a>01076                                                           <span class="keywordflow">else</span>{
<a name="l01077"></a>01077                                                             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ib=0; ib&lt;4 ; ib++){
<a name="l01078"></a>01078                                                               <span class="keywordflow">if</span> (ib==ii) <span class="keywordflow">continue</span>;
<a name="l01079"></a>01079                                                               <span class="keywordflow">if</span>(bary(ib)&gt;=-1.0e-12 &amp;&amp; bary(ib)&lt;=1.0e-12 &amp;&amp; pTet-&gt;neighbor[ib]==-1) {
<a name="l01080"></a>01080                                                                 data.found=<span class="keyword">true</span>;
<a name="l01081"></a>01081                                                                 data.projectedP = interP;
<a name="l01082"></a>01082                                                                 data.outwardFaceNormal= pTet-&gt;TetSurfTris.find(ib)-&gt;second-&gt;outNormal;
<a name="l01083"></a>01083                                                                 data.nodeMeshLocation = 2;      <span class="comment">// boundary node</span>
<a name="l01084"></a>01084                                                                 data.triIndex = pTet-&gt;TetSurfTris.find(ib)-&gt;second-&gt;sID;
<a name="l01085"></a>01085                                                                 <span class="keywordflow">break</span>;
<a name="l01086"></a>01086                                                               }
<a name="l01087"></a>01087                                                             }
<a name="l01088"></a>01088                                                           }
<a name="l01089"></a>01089                                                         }
<a name="l01090"></a>01090                                                         <span class="keywordflow">if</span> (data.found) <span class="keywordflow">break</span>;
<a name="l01091"></a>01091                                                         <span class="comment">//-------- if the intersection point is not in this tetrahedron, move to the next -----</span>
<a name="l01092"></a>01092                                                         
<a name="l01093"></a>01093                                                         <span class="comment">// --- find the index (from 0 to 2) for the point with lowest bary for the surface triangle ----</span>
<a name="l01094"></a>01094                                                         
<a name="l01095"></a>01095                                                         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;3; k++){
<a name="l01096"></a>01096                                                                 <span class="keywordflow">if</span>(pTet-&gt;TetSurfTris.find(sI)-&gt;second-&gt;eleNodes[k]-&gt;sID == pTet-&gt;eleNodes[ii]-&gt;sID) {dI = k; <span class="keywordflow">break</span>;}
<a name="l01097"></a>01097                                                         }
<a name="l01098"></a>01098                                                         
<a name="l01099"></a>01099                                                         pTri = pTet-&gt;TetSurfTris.find(sI)-&gt;second-&gt;neighbor[dI];    <span class="comment">// next neighbor triangle                     </span>
<a name="l01100"></a>01100                                                         pTet = &amp;tetContainer[pTri-&gt;neighTetIndx];                   <span class="comment">// new tetrahedron to move to</span>
<a name="l01101"></a>01101                                                         
<a name="l01102"></a>01102                                                         <span class="keywordflow">for</span> (std::map&lt;size_t,Triangle*&gt;::iterator it = pTet-&gt;TetSurfTris.begin(); it!= pTet-&gt;TetSurfTris.end(); it++){
<a name="l01103"></a>01103                                                                 <span class="keywordflow">if</span> (it-&gt;second-&gt;sID == pTri-&gt;sID){sI = it-&gt;first; <span class="keywordflow">break</span>;}
<a name="l01104"></a>01104                                                         }
<a name="l01105"></a>01105                                                         
<a name="l01106"></a>01106                                                         nn++;
<a name="l01107"></a>01107                                                         <span class="keywordflow">if</span> (nn&gt;100003) {
<a name="l01108"></a>01108                                                           std::cout&lt;&lt; <span class="stringliteral">&quot;minBary = &quot;</span> &lt;&lt;std::setprecision(15) &lt;&lt; baryMin&lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; pTet-&gt;neighbor[ii] &lt;&lt; std::endl;
<a name="l01109"></a>01109                                                           assert(0&amp;&amp;<span class="stringliteral">&quot;The code went inside an infinite loop: Failed to find node-surface intersection point&quot;</span>);
<a name="l01110"></a>01110                                                         }
<a name="l01111"></a>01111                                                 }                        
<a name="l01112"></a>01112                                         }
<a name="l01113"></a>01113                                 }
<a name="l01114"></a>01114                         }
<a name="l01115"></a>01115                         
<a name="l01116"></a>01116                         <span class="comment">// ----------------- boundary node ---------------------</span>
<a name="l01117"></a>01117                         
<a name="l01118"></a>01118                         <span class="keywordflow">else</span> {   
<a name="l01119"></a>01119                                 
<a name="l01120"></a>01120                                 VectorDim org = data.P - data.Dir;      <span class="comment">// old position of the node</span>
<a name="l01121"></a>01121                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iTri;
<a name="l01122"></a>01122                                 
<a name="l01123"></a>01123                                 
<a name="l01124"></a>01124                                 <span class="keywordflow">if</span>(triContainer[data.triIndex]-&gt;intersectWithLine(org,data.P,data.projectedP,iTri)) {
<a name="l01125"></a>01125                                   <span class="comment">//VectorDim avgNormal = data.outwardFaceNormal + triContainer[iTri]-&gt;outNormal;   // average of old &amp; new Triangle normals to avoid vibrations when segments has node that is commuting between two neighbor triangles </span>
<a name="l01126"></a>01126                                   <span class="comment">//std::cout&lt;&lt;std::setprecision(15)&lt;&lt; data.outwardFaceNormal.transpose()&lt;&lt; std::endl;</span>
<a name="l01127"></a>01127                                   <span class="comment">//std::cout&lt;&lt;std::setprecision(15)&lt;&lt; triContainer[iTri]-&gt;outNormal.transpose()&lt;&lt; std::endl;</span>
<a name="l01128"></a>01128                                   <span class="comment">//std::cout&lt;&lt;std::setprecision(15)&lt;&lt; avgNormal.normalized().transpose()&lt;&lt; std::endl;</span>
<a name="l01129"></a>01129                                   <span class="comment">//std::cout&lt;&lt; std::endl;</span>
<a name="l01130"></a>01130                                   <span class="comment">//data.outwardFaceNormal = avgNormal.normalized();</span>
<a name="l01131"></a>01131                                   
<a name="l01132"></a>01132                                   data.outwardFaceNormal= triContainer[iTri]-&gt;outNormal;
<a name="l01133"></a>01133                                   data.newMeshID = triContainer[iTri]-&gt;neighTetIndx;
<a name="l01134"></a>01134                                   data.triIndex = iTri;
<a name="l01135"></a>01135                                   <span class="comment">//std::cout&lt;&lt; &quot;new mesh ID ================== &quot;&lt;&lt;data.newMeshID  &lt;&lt; std::endl;</span>
<a name="l01136"></a>01136                                 }
<a name="l01137"></a>01137                                 <span class="keywordflow">else</span>{
<a name="l01138"></a>01138                                   data.newMeshID = data.currentMeshID;
<a name="l01139"></a>01139                                   data.outwardFaceNormal= triContainer[data.triIndex]-&gt;outNormal;
<a name="l01140"></a>01140                                 }
<a name="l01141"></a>01141                                 data.found=<span class="keyword">true</span>;
<a name="l01142"></a>01142                         }
<a name="l01143"></a>01143                         
<a name="l01144"></a>01144                         
<a name="l01145"></a>01145                 }
<a name="l01146"></a>01146                 <span class="comment">//===================================================================================</span>
<a name="l01147"></a>01147                 <span class="comment">// function to calculate the intersection point between a line and a plane, given</span>
<a name="l01148"></a>01148                 <span class="comment">// the plane normal, point on the plane, line direction, point on the line</span>
<a name="l01149"></a>01149                 <span class="comment">//==================================================================================</span>
<a name="l01150"></a>01150                 
<a name="l01151"></a>01151                 VectorDim getSurfaceIntersection (VectorDim pD, VectorDim pP,<span class="keyword">const</span> VectorDim lD,<span class="keyword">const</span> VectorDim lP){
<a name="l01152"></a>01152                         
<a name="l01153"></a>01153                         <span class="keywordtype">double</span> dm = lD.dot(pD);
<a name="l01154"></a>01154                         
<a name="l01155"></a>01155                         <span class="keywordflow">if</span>(dm == 0.0) assert(0&amp;&amp;<span class="stringliteral">&quot;Dislocation Node is moving parallel to the boundary: unable to get intersection point&quot;</span>);
<a name="l01156"></a>01156                         
<a name="l01157"></a>01157                         <span class="keywordtype">double</span> d = ((pP-lP).dot(pD))/dm;
<a name="l01158"></a>01158                         
<a name="l01159"></a>01159                         <span class="keywordflow">return</span> (lP+d*lD);
<a name="l01160"></a>01160                         
<a name="l01161"></a>01161                 }
<a name="l01162"></a>01162                 
<a name="l01163"></a>01163                 <span class="comment">//===================================================================================</span>
<a name="l01164"></a>01164                 <span class="comment">// function to return a pointer to the including tetrahedron for any given point, </span>
<a name="l01165"></a>01165                 <span class="comment">// or return null if the point is outside the domain</span>
<a name="l01166"></a>01166                 <span class="comment">//==================================================================================</span>
<a name="l01167"></a>01167                 isTetrahedronType findIncludingTet(VectorDim P){
<a name="l01168"></a>01168                         <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;
<a name="l01169"></a>01169                         <span class="keywordtype">int</span> ci; <span class="comment">// index of neighboor tet. -1 means outside.</span>
<a name="l01170"></a>01170                         <span class="keywordtype">int</span> ni; <span class="comment">// </span>
<a name="l01171"></a>01171                         
<a name="l01172"></a>01172                         isTetrahedronType temp=std::make_pair(<span class="keyword">true</span>, (<a class="code" href="classbvpfe_1_1_tetrahedron.html">Tetrahedron</a>*) NULL);
<a name="l01173"></a>01173                         
<a name="l01174"></a>01174                         <span class="comment">//----- starting Tet, random start point ------------</span>
<a name="l01175"></a>01175                         ci = int(tetContainer.size()/2);     
<a name="l01176"></a>01176                         
<a name="l01177"></a>01177                         <span class="keywordflow">while</span> ((!found)&amp;&amp;(ci&gt;=0))
<a name="l01178"></a>01178                         {
<a name="l01179"></a>01179                                 temp.second = &amp;tetContainer[ci];
<a name="l01180"></a>01180                                 ci = temp.second-&gt;nextNeighbor(P,found,ni);    <span class="comment">// returns -10 if the point is inside the Tet</span>
<a name="l01181"></a>01181                         }
<a name="l01182"></a>01182                         
<a name="l01183"></a>01183                         temp.first=found;
<a name="l01184"></a>01184                         
<a name="l01185"></a>01185                         <span class="comment">//                      if (!found)   // this means it is outside the domain</span>
<a name="l01186"></a>01186                         <span class="comment">//                      {</span>
<a name="l01187"></a>01187                         <span class="comment">//                              temp.first=false;</span>
<a name="l01188"></a>01188                         <span class="comment">//                      //      temp.second = NULL;</span>
<a name="l01189"></a>01189                         <span class="comment">//                              //std::cout &lt;&lt; &quot;============= ERROR: Searching for point outside the domain ==============&quot; &lt;&lt; std ::endl; </span>
<a name="l01190"></a>01190                         <span class="comment">//                              //assert(0);</span>
<a name="l01191"></a>01191                         <span class="comment">//                      }</span>
<a name="l01192"></a>01192                         
<a name="l01193"></a>01193                         <span class="keywordflow">return</span> temp;
<a name="l01194"></a>01194                 } 
<a name="l01195"></a>01195                 
<a name="l01196"></a>01196                 <span class="comment">//====================================================================================</span>
<a name="l01197"></a>01197                 <span class="comment">// Function to initally find the dislocation node position in the FE mesh</span>
<a name="l01198"></a>01198                 <span class="comment">//=====================================================================================</span>
<a name="l01199"></a>01199                 <span class="keywordtype">void</span> findIncludingTet (<a class="code" href="structmmdl_1_1_search_data.html">mmdl::SearchData&lt;dim&gt;</a> &amp; data){
<a name="l01200"></a>01200                  
<a name="l01201"></a>01201                   <span class="comment">//---- initialize ---------------</span>
<a name="l01202"></a>01202                   <span class="comment">//data.currentMeshID = </span>
<a name="l01203"></a>01203                   data.newMeshID = int(tetContainer.size()/2);
<a name="l01204"></a>01204                   
<a name="l01205"></a>01205                   <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;
<a name="l01206"></a>01206                   
<a name="l01207"></a>01207                   <span class="keywordflow">while</span> (!found){
<a name="l01208"></a>01208                     found = tetContainer[data.newMeshID].isInsideTet(data) || data.nodeMeshLocation != -1;
<a name="l01209"></a>01209                   }
<a name="l01210"></a>01210                   
<a name="l01211"></a>01211                 }
<a name="l01212"></a>01212                 
<a name="l01213"></a>01213                 
<a name="l01214"></a>01214                 <span class="comment">//===================================================================================</span>
<a name="l01215"></a>01215                 <span class="comment">// function to detect the intersection line between a slip plane, and the mesh surface</span>
<a name="l01216"></a>01216                 <span class="comment">//==================================================================================</span>
<a name="l01217"></a>01217 
<a name="l01218"></a>01218 <span class="comment">//              void get_planeMeshIntersection(const VectorDim&amp; x0, const VectorDim&amp; n, std::map&lt; unsigned int, std::pair&lt;VectorDim,VectorDim&gt; &gt;&amp; collisionContainer, const unsigned int gpID){</span>
<a name="l01219"></a>01219                 <span class="keywordtype">void</span> get_planeMeshIntersection(<span class="keyword">const</span> VectorDim&amp; x0, <span class="keyword">const</span> VectorDim&amp; n, 
<a name="l01220"></a>01220                 <span class="comment">/*                          */</span> std::map&lt; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, std::pair&lt;VectorDim,VectorDim&gt;,std::less&lt;unsigned int&gt;, Eigen::aligned_allocator&lt;std::pair&lt;<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>,std::pair&lt;VectorDim,VectorDim&gt; &gt; &gt; &gt;&amp; collisionContainer, 
<a name="l01221"></a>01221                 <span class="comment">/*                          */</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gpID){
<a name="l01222"></a>01222                         
<a name="l01223"></a>01223                         <span class="keywordtype">double</span> tol = 1.0e-7;
<a name="l01224"></a>01224 
<a name="l01225"></a>01225                         <span class="comment">//FILE *ft =fopen(&quot;triangles_gp.txt&quot;, &quot;a&quot;);</span>
<a name="l01226"></a>01226                         
<a name="l01227"></a>01227                         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;triContainer.size();i++){
<a name="l01228"></a>01228                                 std::vector&lt;VectorDim&gt; intersectionPoints;
<a name="l01229"></a>01229                                 
<a name="l01230"></a>01230                                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j&lt; 3; j++){
<a name="l01231"></a>01231                                         VectorDim v0 = triContainer[i]-&gt;eleNodes[j]-&gt;P;
<a name="l01232"></a>01232                                         VectorDim v1 = triContainer[i]-&gt;eleNodes[(j+1)%3]-&gt;P;
<a name="l01233"></a>01233                                         <span class="keywordtype">double</span> u = getSurfaceIntersectionPar (x0,n,v0,v1);
<a name="l01234"></a>01234                                         
<a name="l01235"></a>01235                                         <span class="keywordflow">if</span>(u&gt;=0 &amp;&amp; u&lt;=1.0){ 
<a name="l01236"></a>01236                                                 VectorDim P = v0 + u*(v1-v0);
<a name="l01237"></a>01237                                                 
<a name="l01238"></a>01238                                                 
<a name="l01239"></a>01239                                                 <span class="keywordtype">bool</span> isDifferent=<span class="keyword">true</span>;
<a name="l01240"></a>01240                                                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0;k&lt;intersectionPoints.size();k++){
<a name="l01241"></a>01241                                                         isDifferent*= (P-intersectionPoints[k]).squaredNorm()&gt;tol;
<a name="l01242"></a>01242                                                 }
<a name="l01243"></a>01243                                                 
<a name="l01244"></a>01244                                                 <span class="keywordflow">if</span> (isDifferent){
<a name="l01245"></a>01245                                                         intersectionPoints.push_back(P);
<a name="l01246"></a>01246                                                 }
<a name="l01247"></a>01247                                         }
<a name="l01248"></a>01248                                 }
<a name="l01249"></a>01249                                 
<a name="l01250"></a>01250                                 assert(intersectionPoints.size()&lt;3);
<a name="l01251"></a>01251                                 
<a name="l01252"></a>01252                                 
<a name="l01253"></a>01253                                 
<a name="l01254"></a>01254                                 <span class="keywordflow">if</span> (intersectionPoints.size()==2){
<a name="l01255"></a>01255                                         <span class="comment">//collisionContainer.push_back(std::make_pair(intersectionPoints[0],intersectionPoints[1]));</span>
<a name="l01256"></a>01256                                         collisionContainer.insert(std::make_pair(triContainer[i]-&gt;sID,std::make_pair(intersectionPoints[0],intersectionPoints[1])));
<a name="l01257"></a>01257                                         
<a name="l01258"></a>01258                                         
<a name="l01259"></a>01259                                         <span class="comment">//---------------- generate custom Quadrature points around the triangle-glide plane intersection line------</span>
<a name="l01260"></a>01260                                         <span class="comment">//triContainer[i]-&gt;makeLocalQuadPoints(intersectionPoints[0],intersectionPoints[1] , gpID);</span>
<a name="l01261"></a>01261                                         
<a name="l01262"></a>01262 <span class="comment">//                                      fprintf (ft, &quot;%22.15e %22.15e %22.15e %22.15e %22.15e %22.15e %22.15e %22.15e %22.15e \n&quot;,</span>
<a name="l01263"></a>01263 <span class="comment">//                                               triContainer[i]-&gt;eleNodes[0]-&gt;P(0),triContainer[i]-&gt;eleNodes[0]-&gt;P(1), triContainer[i]-&gt;eleNodes[0]-&gt;P(2),</span>
<a name="l01264"></a>01264 <span class="comment">//                                               triContainer[i]-&gt;eleNodes[1]-&gt;P(0),triContainer[i]-&gt;eleNodes[1]-&gt;P(1), triContainer[i]-&gt;eleNodes[1]-&gt;P(2),</span>
<a name="l01265"></a>01265 <span class="comment">//                                               triContainer[i]-&gt;eleNodes[2]-&gt;P(0),triContainer[i]-&gt;eleNodes[2]-&gt;P(1), triContainer[i]-&gt;eleNodes[2]-&gt;P(2));</span>
<a name="l01266"></a>01266                                                  
<a name="l01267"></a>01267                                         
<a name="l01268"></a>01268 <span class="comment">//                              std::cout&lt;&lt;&quot;Tri ID  &quot; &lt;&lt; triContainer[i]-&gt;sID &lt;&lt; std::endl;     </span>
<a name="l01269"></a>01269 <span class="comment">//                              std::cout&lt;&lt; std::setprecision(15) &lt;&lt;triContainer[i]-&gt;eleNodes[0]-&gt;P.transpose() &lt;&lt; std::endl;</span>
<a name="l01270"></a>01270 <span class="comment">//                              std::cout&lt;&lt; std::setprecision(15) &lt;&lt;triContainer[i]-&gt;eleNodes[1]-&gt;P.transpose() &lt;&lt; std::endl;</span>
<a name="l01271"></a>01271 <span class="comment">//                              std::cout&lt;&lt; std::setprecision(15) &lt;&lt;triContainer[i]-&gt;eleNodes[2]-&gt;P.transpose() &lt;&lt; std::endl;</span>
<a name="l01272"></a>01272 <span class="comment">//                              std::cout&lt;&lt; std::setprecision(15) &lt;&lt; intersectionPoints[0].transpose() &lt;&lt; &quot;   &quot; &lt;&lt; intersectionPoints[1].transpose() &lt;&lt; std::endl;</span>
<a name="l01273"></a>01273 <span class="comment">//                              std::cout&lt;&lt;  std::endl;</span>
<a name="l01274"></a>01274                                         
<a name="l01275"></a>01275                                 }
<a name="l01276"></a>01276                                 
<a name="l01277"></a>01277                         }
<a name="l01278"></a>01278                         
<a name="l01279"></a>01279                         <span class="comment">//fclose(ft);</span>
<a name="l01280"></a>01280 
<a name="l01281"></a>01281                         
<a name="l01282"></a>01282                 }
<a name="l01283"></a>01283                 
<a name="l01284"></a>01284                 
<a name="l01285"></a>01285                 <span class="comment">//===================================================================================</span>
<a name="l01286"></a>01286                 <span class="comment">// function to calculate the intersection point between a line and a plane, given</span>
<a name="l01287"></a>01287                 <span class="comment">// the plane normal, point on the plane, line direction, point on the line</span>
<a name="l01288"></a>01288                 <span class="comment">//==================================================================================</span>
<a name="l01289"></a>01289                 
<a name="l01290"></a>01290                 <span class="keywordtype">double</span> getSurfaceIntersectionPar (VectorDim x0, VectorDim n,<span class="keyword">const</span> VectorDim v0,<span class="keyword">const</span> VectorDim v1){
<a name="l01291"></a>01291                         
<a name="l01292"></a>01292                         <span class="keywordflow">return</span> ((x0-v0).dot(n)) / (v1-v0).dot(n);
<a name="l01293"></a>01293                 }               
<a name="l01294"></a>01294                 
<a name="l01295"></a>01295                 <span class="comment">//===================================================================================</span>
<a name="l01296"></a>01296                 <span class="comment">// function to output Tetrahedron mesh</span>
<a name="l01297"></a>01297                 <span class="comment">//==================================================================================</span>
<a name="l01298"></a>01298                 <span class="comment">//              void outputMesh(const size_t&amp; runID, const size_t&amp; outputFrequency){</span>
<a name="l01299"></a>01299                 <span class="keywordtype">void</span> outputMesh()<span class="keyword"> const </span>{
<a name="l01300"></a>01300                         
<a name="l01301"></a>01301                         <span class="comment">//mmdl::SequentialOutputFile&lt;&#39;N&#39;,1&gt;::set_increment(outputFrequency); // Vertices_file;</span>
<a name="l01302"></a>01302                         <span class="comment">//mmdl::SequentialOutputFile&lt;&#39;N&#39;,1&gt;::set_count(runID); // Vertices_file;</span>
<a name="l01303"></a>01303                         mmdl::SequentialOutputFile&lt;&#39;N&#39;,true&gt; nodesFile;
<a name="l01304"></a>01304                         <span class="comment">//                      mmdl::UniqueOutputFile&lt;&#39;N&#39;&gt; nodesFile;</span>
<a name="l01305"></a>01305                         <span class="keywordflow">for</span> (NodeContainerType::const_iterator iter=nodeContainer.begin();iter!=nodeContainer.end();++iter){
<a name="l01306"></a>01306                                 nodesFile&lt;&lt; iter-&gt;sID&lt;&lt;<span class="stringliteral">&quot;        &quot;</span> &lt;&lt; iter-&gt;P.transpose()&lt;&lt;<span class="stringliteral">&quot;     &quot;</span>&lt;&lt;iter-&gt;isBoundaryNode&lt;&lt;std::endl;
<a name="l01307"></a>01307                         }
<a name="l01308"></a>01308                         
<a name="l01309"></a>01309                         <span class="comment">//output_T_File();</span>
<a name="l01310"></a>01310                         
<a name="l01311"></a>01311                         <span class="comment">//              }</span>
<a name="l01312"></a>01312                         
<a name="l01313"></a>01313                         <span class="comment">//======================================================================================================</span>
<a name="l01314"></a>01314                         <span class="comment">// Function to output the T files that contains the mesh connectivity data</span>
<a name="l01315"></a>01315                         <span class="comment">//=====================================================================================================</span>
<a name="l01316"></a>01316                         <span class="comment">//              void output_T_File(){</span>
<a name="l01317"></a>01317                         mmdl::SequentialOutputFile&lt;&#39;T&#39;,true&gt; tetFile;
<a name="l01318"></a>01318                         <span class="comment">//              mmdl::UniqueOutputFile&lt;&#39;T&#39;&gt; tetFile;</span>
<a name="l01319"></a>01319                         
<a name="l01320"></a>01320                         <span class="keywordflow">for</span> (TetContainerType::const_iterator iter=tetContainer.begin();iter!=tetContainer.end();++iter){
<a name="l01321"></a>01321                                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0;k&lt;iter-&gt;eleNodes.size()-1;++k){
<a name="l01322"></a>01322                                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=k+1;j&lt;iter-&gt;eleNodes.size();++j){
<a name="l01323"></a>01323                                                 tetFile&lt;&lt; iter-&gt;eleNodes[k]-&gt;sID&lt;&lt;<span class="stringliteral">&quot;     &quot;</span>&lt;&lt;iter-&gt;eleNodes[j]-&gt;sID&lt;&lt;<span class="stringliteral">&quot; 0&quot;</span>&lt;&lt;std::endl;
<a name="l01324"></a>01324                                         }
<a name="l01325"></a>01325                                 }
<a name="l01326"></a>01326                         }
<a name="l01327"></a>01327                 }
<a name="l01328"></a>01328                 
<a name="l01329"></a>01329                 <span class="comment">//==================================================================================</span>
<a name="l01330"></a>01330                 <span class="comment">// function to remove all previous traction and displacement boundary conditions</span>
<a name="l01331"></a>01331                 <span class="comment">// called before setting new ones</span>
<a name="l01332"></a>01332                 <span class="comment">//==================================================================================</span>
<a name="l01333"></a>01333                 
<a name="l01334"></a>01334                 <span class="keywordtype">void</span> removeBoundaryConditions(){
<a name="l01335"></a>01335                         
<a name="l01336"></a>01336                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i =0; i&lt;nodeContainer.size(); i++){
<a name="l01337"></a>01337                                 <span class="keywordflow">if</span>(nodeContainer[i].isBoundaryNode){
<a name="l01338"></a>01338                                         <span class="comment">//nodeContainer[i].traction = VectorDim::Zero();         // set traction to be zero</span>
<a name="l01339"></a>01339                                         nodeContainer[i].remove_BCs();                        <span class="comment">// set displacement BC to be false</span>
<a name="l01340"></a>01340                                 }
<a name="l01341"></a>01341                         } 
<a name="l01342"></a>01342                         
<a name="l01343"></a>01343                 }
<a name="l01344"></a>01344                 
<a name="l01345"></a>01345                 
<a name="l01346"></a>01346                 
<a name="l01347"></a>01347                 <span class="comment">//================================================================================</span>
<a name="l01348"></a>01348                 <span class="comment">//  function to set the dof of a face (the whole face)</span>
<a name="l01349"></a>01349                 <span class="comment">//================================================================================</span>
<a name="l01350"></a>01350                 <span class="comment">//      template &lt;typename T&gt;</span>
<a name="l01351"></a>01351                 <span class="comment">/*</span>
<a name="l01352"></a>01352 <span class="comment">                 void setFaceDof(int iface, int idof, double val)</span>
<a name="l01353"></a>01353 <span class="comment">                 {</span>
<a name="l01354"></a>01354 <span class="comment">                 bvpfe::Face* pFace;</span>
<a name="l01355"></a>01355 <span class="comment">                 std::map&lt;size_t,bvpfe::Triangle*&gt;::iterator it;</span>
<a name="l01356"></a>01356 <span class="comment">                 </span>
<a name="l01357"></a>01357 <span class="comment">                 idof = idof -1;</span>
<a name="l01358"></a>01358 <span class="comment">                 pFace = faceContainer.find(iface)-&gt;second;    // pointer to the targetted face</span>
<a name="l01359"></a>01359 <span class="comment">                 </span>
<a name="l01360"></a>01360 <span class="comment">                 //----- loop over the face triangles ---</span>
<a name="l01361"></a>01361 <span class="comment">                 </span>
<a name="l01362"></a>01362 <span class="comment">                 for (it= pFace-&gt;triContainer.begin() ; it != pFace-&gt;triContainer.end(); it++ )</span>
<a name="l01363"></a>01363 <span class="comment">                 {</span>
<a name="l01364"></a>01364 <span class="comment">                 //----- loop over the triangle nodes ---</span>
<a name="l01365"></a>01365 <span class="comment">                 for(unsigned int i = 0; i&lt;it-&gt;second-&gt;Nnodes; i++)</span>
<a name="l01366"></a>01366 <span class="comment">                 {</span>
<a name="l01367"></a>01367 <span class="comment">                 //std::cout&lt;&lt; it-&gt;second-&gt;eleNodes[i]-&gt;sID;</span>
<a name="l01368"></a>01368 <span class="comment">                 //VectorDim uInf = pT-&gt;displacement(it-&gt;second-&gt;eleNodes[i]-&gt;P);</span>
<a name="l01369"></a>01369 <span class="comment">                 it-&gt;second-&gt;eleNodes[i]-&gt;setBC (idof , val-it-&gt;second-&gt;eleNodes[i]-&gt;uInf(idof)*0);</span>
<a name="l01370"></a>01370 <span class="comment">                 }</span>
<a name="l01371"></a>01371 <span class="comment">                 }</span>
<a name="l01372"></a>01372 <span class="comment">                 </span>
<a name="l01373"></a>01373 <span class="comment">                 </span>
<a name="l01374"></a>01374 <span class="comment">                 }*/</span>
<a name="l01375"></a>01375                 <span class="comment">//===========================================================================================</span>
<a name="l01376"></a>01376         };
<a name="l01377"></a>01377         
<a name="l01378"></a>01378         
<a name="l01379"></a>01379         
<a name="l01380"></a>01380 }  <span class="comment">//  namespace bvpfe</span>
<a name="l01381"></a>01381 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 12 2012 17:24:28 for Mechanics of Defect Evolution Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
